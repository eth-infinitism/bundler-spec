{"version":3,"sources":["webpack:///./node_modules/monaco-vim/lib/cm/keymap_vim.js"],"names":["Object","defineProperty","exports","value","Vim","undefined","obj","_typeof","Symbol","iterator","constructor","prototype","_cm_adapter","_cm_adapter2","__esModule","default","defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","replace","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","Pos","detachVimMap","cm","next","attached","this","keyMap","vim","rmClass","getWrapperElement","attach","attachVimMap","setOption","off","onCursorActivity","state","leaveVimMode","prev","signal","mode","on","maybeInitVimState","enterVimMode","cmKey","key","vimKey","charAt","pieces","split","lastPiece","length","hasCharacter","i","piece","modifiers","specialKeys","isUpperCase","toLowerCase","join","cmKeyToVimKey","cmd","findKey","defineOption","val","getOption","Init","test","Enter","Backspace","Delete","Insert","numberRegex","wordCharTest","isWordChar","ch","bigWordCharTest","makeKeyRange","start","size","push","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","isLine","line","firstLine","lastLine","isLowerCase","k","isWhiteSpaceString","isEndOfSentenceSymbol","indexOf","inArray","arr","options","defaultValue","aliases","callback","Error","cfg","option","scope","local","vimGlobalState","lastInsertModeKeyTimer","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","marks","fakeCursor","insertMode","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","sel","resetVimGlobalState","pointer","head","tail","buffer","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","Array","cachedCursor","add","oldCur","newCur","curMark","useNextSlot","cursor","trashMark","clear","setBookmark","markPos","find","cursorEqual","move","offset","mark","inc","getCursor","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","exitMacroRecordMode","enterMacroRecordMode","registerName","register","getRegister","openDialog","bottom","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","defineEx","prefix","func","exCommands","commandMap_","handleKey","origin","command","handleMacroRecording","clearInputState","pushText","logKey","handleEsc","exitVisualMode","exitInsertMode","keyBuffer","keysAreChars","match","commandDispatcher","matchCommand","slice","thisMatch","window","clearTimeout","setTimeout","selections","listSelections","here","replaceRange","offsetCursor","pop","handleKeyInsertMode","keysMatcher","exec","pushRepeatDigit","handleKeyNonInsertMode","operation","curOp","isVimOp","substring","index","doKeyToKey","processCommand","e","console","handleEx","input","defineMotion","fn","motions","defineAction","actions","defineOperator","operators","mapCommand","args","extra","_mapCommand","defineRegister","registers","prefixRepeat","motionRepeat","reason","Register","text","insertModeChanges","searchQueries","unnamedRegister","historyBuffer","initialPrefix","n","getRepeat","repeat","parseInt","setText","pushInsertModeChanges","pushSearchQuery","query","toString","isValidRegister","shiftNumericRegisters_","nextMatch","up","dir","element","j","pushInput","splice","reset","bestMatch","matches","partial","full","commandMatch","commandMatches","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","handleQuery","shift","showPrompt","onClose","scrollTo","left","top","logSearchQuery","desc","searchPromptDesc","onKeyUp","close","parsedQuery","keyName","target","selectionEnd","selectionStart","Math","min","updateSearchQuery","scrollIntoView","_findNext","clearSearchHighlight","onKeyDown","e_stop","focus","word","expandWordUnderCursor","isKeyword","getLine","end","setCursor","ignoreCase","smartCase","showConfirm","onPromptClose","onPromptKeyDown","exArgs","selectValueOnOpen","newHead","newAnchor","origHead","copyCursor","clipCursorToContent","origAnchor","anchor","oldHead","oldAnchor","noRepeat","motionResult","recordJumpPosition","Infinity","updateCmSelection","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","ranges","lineLength","tmp","_cm","expandSelectionToLine","selection","getRange","lines","clipToLine","setSelections","primary","operatorMoveTo","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","range","floor","moveToBottomLine","expandToLine","findNext","isReversed","highlightSearchMatches","goToMark","pos","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","equal","between","cursorIsBetween","moveByCharacters","cur","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","last","moveToStartOfLine","charCoords","res","findPosV","hitSide","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","nextChar","idx","ln","stop","curr","last_valid","skip_empty_lines","reverse","curr_index","findSentence","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","words","emptyLineIsWord","findWord","eodCh","from","to","shortCircuit","firstWord","lastWord","moveToWord","moveTillCharacter","_moveToCharacter","recordLastCharacterSearch","moveToCharacter","moveToSymbol","symb","endLine","lineCount","curCh","lineText","nextCh","lastCh","reverseSymb","depth","curMoveThrough","symbolToMode","init","findSymbolModes","isComplete","lineLen","findSymbol","_moveToColumn","retval","clipPos","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","findMatchingBracket","moveToLineOrEdgeOfDocument","lineNum","textObjectManipulation","bracketRegexp","openSym","scanForBracket","selectCompanionObject","'","len","chars","firstIndex","findBeginningAndEnd","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fillArray","times","change","finalHead","inVisualBlock","getSelection","replacement","replaceSelections","lastState","prevLineEnd","Number","MAX_VALUE","wasLastLine","commands","newlineAndIndent","enterInsertMode","indent","startLine","pushUndoStop","indentLine","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","moveCurrentLineTo","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","height","max","onChange","getInputField","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","str","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","lastSelectionCurEnd","selectedArea","getCurrentSelectedAreaRange","block","width","setSelection","getLastSelectedAreaRange","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","extendLineToColumn","undo","repeatFn","redo","setRegister","setMark","replaceTo","replaceWith","replaceWithStr","incrementNumberToken","numberStr","lineStr","re","baseStr","digits","base","zeroPadding","substr","repeatLastEdit","_repeatLastEdit","includeLineBreak","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","call","cur3","cur1before2","cur2before3","trim","s","column","isClipped","primIndex","atAnchor","atHead","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","updateFakeCursor","exclusive","headOffset","anchorOffset","right","moveHead","_forward","noSymbol","getHead","wordStart","bracket","section","comment","found","method","preprocess","token","charTests","foundWord","charIdxInLine","markName","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","SearchState","searchState_","dialog","template","shortText","prompt","splitBySeparator","argString","separator","slashes","findUnescapedSeparators","tokens","escapeNextChar","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","unescapes","parseQuery","RegExp","regexPart","forceIgnoreCase","out","specialComesNext","translateRegex","openNotification","duration","alert","raw","rawQuery","r1","r2","props","regexEqual","searchState","removeOverlay","source","matchSol","stream","sol","backUp","eol","skipToEnd","addOverlay","showMatchesOnScrollbar","history","doc","done","event","lastModTime","changeHistory","filter","el","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","StringStream","commandName","params","parseInput_","matchCommand_","parseCommandArgs_","toInput","result","eatWhile","eat","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","mapping","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","number","pattern","err","eatSpace","opts","decimal","hex","octal","parseArgs","lineStart","radix","numPart","textPart","matchPart","a","b","compareFn","textOld","anum","bnum","global","splitBySlash","matchedLines","content","nextCommand","substitute","trailing","flagsPart","count","replacePart","confirm","output","peek","matched","matcher","unescapeRegexReplace","translateRegexReplace","startPos","searchCursor","exMode","lastPos","replaceAll","newText","_value","savedCallback","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","insertModeChangeRegister","lastChange","selLength","logInsertModeChange","imc","repeatInsertModeChanges","changeObj","maybeReset","somethingSelected","handleExternalSelection","markText","className","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","getOffset","detach","fallthrough"],"mappings":"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","file":"004beebb-60c2189c71f89e033d4b.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Vim = undefined;\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n}; /* eslint-disable */\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Parts of the original code has been modified to work with monaco\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeyMap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\nvar _cm_adapter = require('../cm_adapter');\nvar _cm_adapter2 = _interopRequireDefault(_cm_adapter);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar defaultKeymap = [\n// Key to key mapping. This goes first to make it possible to override\n// existing mappings.\n{\n  keys: '<Left>',\n  type: 'keyToKey',\n  toKeys: 'h'\n}, {\n  keys: '<Right>',\n  type: 'keyToKey',\n  toKeys: 'l'\n}, {\n  keys: '<Up>',\n  type: 'keyToKey',\n  toKeys: 'k'\n}, {\n  keys: '<Down>',\n  type: 'keyToKey',\n  toKeys: 'j'\n}, {\n  keys: '<Space>',\n  type: 'keyToKey',\n  toKeys: 'l'\n}, {\n  keys: '<BS>',\n  type: 'keyToKey',\n  toKeys: 'h',\n  context: 'normal'\n}, {\n  keys: '<C-Space>',\n  type: 'keyToKey',\n  toKeys: 'W'\n}, {\n  keys: '<C-BS>',\n  type: 'keyToKey',\n  toKeys: 'B',\n  context: 'normal'\n}, {\n  keys: '<S-Space>',\n  type: 'keyToKey',\n  toKeys: 'w'\n}, {\n  keys: '<S-BS>',\n  type: 'keyToKey',\n  toKeys: 'b',\n  context: 'normal'\n}, {\n  keys: '<C-n>',\n  type: 'keyToKey',\n  toKeys: 'j'\n}, {\n  keys: '<C-p>',\n  type: 'keyToKey',\n  toKeys: 'k'\n}, {\n  keys: '<C-[>',\n  type: 'keyToKey',\n  toKeys: '<Esc>'\n}, {\n  keys: '<C-c>',\n  type: 'keyToKey',\n  toKeys: '<Esc>'\n}, {\n  keys: '<C-[>',\n  type: 'keyToKey',\n  toKeys: '<Esc>',\n  context: 'insert'\n}, {\n  keys: '<C-c>',\n  type: 'keyToKey',\n  toKeys: '<Esc>',\n  context: 'insert'\n}, {\n  keys: 's',\n  type: 'keyToKey',\n  toKeys: 'cl',\n  context: 'normal'\n}, {\n  keys: 's',\n  type: 'keyToKey',\n  toKeys: 'c',\n  context: 'visual'\n}, {\n  keys: 'S',\n  type: 'keyToKey',\n  toKeys: 'cc',\n  context: 'normal'\n}, {\n  keys: 'S',\n  type: 'keyToKey',\n  toKeys: 'VdO',\n  context: 'visual'\n}, {\n  keys: '<Home>',\n  type: 'keyToKey',\n  toKeys: '0'\n}, {\n  keys: '<End>',\n  type: 'keyToKey',\n  toKeys: '$'\n}, {\n  keys: '<PageUp>',\n  type: 'keyToKey',\n  toKeys: '<C-b>'\n}, {\n  keys: '<PageDown>',\n  type: 'keyToKey',\n  toKeys: '<C-f>'\n}, {\n  keys: '<CR>',\n  type: 'keyToKey',\n  toKeys: 'j^',\n  context: 'normal'\n}, {\n  keys: '<CR>',\n  type: 'keyToKey',\n  toKeys: 'j^',\n  context: 'visual'\n}, {\n  keys: '<Ins>',\n  type: 'action',\n  action: 'toggleOverwrite',\n  context: 'insert'\n},\n// Motions\n{\n  keys: 'H',\n  type: 'motion',\n  motion: 'moveToTopLine',\n  motionArgs: {\n    linewise: true,\n    toJumplist: true\n  }\n}, {\n  keys: 'M',\n  type: 'motion',\n  motion: 'moveToMiddleLine',\n  motionArgs: {\n    linewise: true,\n    toJumplist: true\n  }\n}, {\n  keys: 'L',\n  type: 'motion',\n  motion: 'moveToBottomLine',\n  motionArgs: {\n    linewise: true,\n    toJumplist: true\n  }\n}, {\n  keys: 'h',\n  type: 'motion',\n  motion: 'moveByCharacters',\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: 'l',\n  type: 'motion',\n  motion: 'moveByCharacters',\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: 'j',\n  type: 'motion',\n  motion: 'moveByLines',\n  motionArgs: {\n    forward: true,\n    linewise: true\n  }\n}, {\n  keys: 'k',\n  type: 'motion',\n  motion: 'moveByLines',\n  motionArgs: {\n    forward: false,\n    linewise: true\n  }\n}, {\n  keys: 'gj',\n  type: 'motion',\n  motion: 'moveByDisplayLines',\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: 'gk',\n  type: 'motion',\n  motion: 'moveByDisplayLines',\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: 'w',\n  type: 'motion',\n  motion: 'moveByWords',\n  motionArgs: {\n    forward: true,\n    wordEnd: false\n  }\n}, {\n  keys: 'W',\n  type: 'motion',\n  motion: 'moveByWords',\n  motionArgs: {\n    forward: true,\n    wordEnd: false,\n    bigWord: true\n  }\n}, {\n  keys: 'e',\n  type: 'motion',\n  motion: 'moveByWords',\n  motionArgs: {\n    forward: true,\n    wordEnd: true,\n    inclusive: true\n  }\n}, {\n  keys: 'E',\n  type: 'motion',\n  motion: 'moveByWords',\n  motionArgs: {\n    forward: true,\n    wordEnd: true,\n    bigWord: true,\n    inclusive: true\n  }\n}, {\n  keys: 'b',\n  type: 'motion',\n  motion: 'moveByWords',\n  motionArgs: {\n    forward: false,\n    wordEnd: false\n  }\n}, {\n  keys: 'B',\n  type: 'motion',\n  motion: 'moveByWords',\n  motionArgs: {\n    forward: false,\n    wordEnd: false,\n    bigWord: true\n  }\n}, {\n  keys: 'ge',\n  type: 'motion',\n  motion: 'moveByWords',\n  motionArgs: {\n    forward: false,\n    wordEnd: true,\n    inclusive: true\n  }\n}, {\n  keys: 'gE',\n  type: 'motion',\n  motion: 'moveByWords',\n  motionArgs: {\n    forward: false,\n    wordEnd: true,\n    bigWord: true,\n    inclusive: true\n  }\n}, {\n  keys: '{',\n  type: 'motion',\n  motion: 'moveByParagraph',\n  motionArgs: {\n    forward: false,\n    toJumplist: true\n  }\n}, {\n  keys: '}',\n  type: 'motion',\n  motion: 'moveByParagraph',\n  motionArgs: {\n    forward: true,\n    toJumplist: true\n  }\n}, {\n  keys: '(',\n  type: 'motion',\n  motion: 'moveBySentence',\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: ')',\n  type: 'motion',\n  motion: 'moveBySentence',\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: '<C-f>',\n  type: 'motion',\n  motion: 'moveByPage',\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: '<C-b>',\n  type: 'motion',\n  motion: 'moveByPage',\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: '<C-d>',\n  type: 'motion',\n  motion: 'moveByScroll',\n  motionArgs: {\n    forward: true,\n    explicitRepeat: true\n  }\n}, {\n  keys: '<C-u>',\n  type: 'motion',\n  motion: 'moveByScroll',\n  motionArgs: {\n    forward: false,\n    explicitRepeat: true\n  }\n}, {\n  keys: 'gg',\n  type: 'motion',\n  motion: 'moveToLineOrEdgeOfDocument',\n  motionArgs: {\n    forward: false,\n    explicitRepeat: true,\n    linewise: true,\n    toJumplist: true\n  }\n}, {\n  keys: 'G',\n  type: 'motion',\n  motion: 'moveToLineOrEdgeOfDocument',\n  motionArgs: {\n    forward: true,\n    explicitRepeat: true,\n    linewise: true,\n    toJumplist: true\n  }\n}, {\n  keys: '0',\n  type: 'motion',\n  motion: 'moveToStartOfLine'\n}, {\n  keys: '^',\n  type: 'motion',\n  motion: 'moveToFirstNonWhiteSpaceCharacter'\n}, {\n  keys: '+',\n  type: 'motion',\n  motion: 'moveByLines',\n  motionArgs: {\n    forward: true,\n    toFirstChar: true\n  }\n}, {\n  keys: '-',\n  type: 'motion',\n  motion: 'moveByLines',\n  motionArgs: {\n    forward: false,\n    toFirstChar: true\n  }\n}, {\n  keys: '_',\n  type: 'motion',\n  motion: 'moveByLines',\n  motionArgs: {\n    forward: true,\n    toFirstChar: true,\n    repeatOffset: -1\n  }\n}, {\n  keys: '$',\n  type: 'motion',\n  motion: 'moveToEol',\n  motionArgs: {\n    inclusive: true\n  }\n}, {\n  keys: '%',\n  type: 'motion',\n  motion: 'moveToMatchedSymbol',\n  motionArgs: {\n    inclusive: true,\n    toJumplist: true\n  }\n}, {\n  keys: 'f<character>',\n  type: 'motion',\n  motion: 'moveToCharacter',\n  motionArgs: {\n    forward: true,\n    inclusive: true\n  }\n}, {\n  keys: 'F<character>',\n  type: 'motion',\n  motion: 'moveToCharacter',\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: 't<character>',\n  type: 'motion',\n  motion: 'moveTillCharacter',\n  motionArgs: {\n    forward: true,\n    inclusive: true\n  }\n}, {\n  keys: 'T<character>',\n  type: 'motion',\n  motion: 'moveTillCharacter',\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: ';',\n  type: 'motion',\n  motion: 'repeatLastCharacterSearch',\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: ',',\n  type: 'motion',\n  motion: 'repeatLastCharacterSearch',\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: '\\'<character>',\n  type: 'motion',\n  motion: 'goToMark',\n  motionArgs: {\n    toJumplist: true,\n    linewise: true\n  }\n}, {\n  keys: '`<character>',\n  type: 'motion',\n  motion: 'goToMark',\n  motionArgs: {\n    toJumplist: true\n  }\n}, {\n  keys: ']`',\n  type: 'motion',\n  motion: 'jumpToMark',\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: '[`',\n  type: 'motion',\n  motion: 'jumpToMark',\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: ']\\'',\n  type: 'motion',\n  motion: 'jumpToMark',\n  motionArgs: {\n    forward: true,\n    linewise: true\n  }\n}, {\n  keys: '[\\'',\n  type: 'motion',\n  motion: 'jumpToMark',\n  motionArgs: {\n    forward: false,\n    linewise: true\n  }\n},\n// the next two aren't motions but must come before more general motion declarations\n{\n  keys: ']p',\n  type: 'action',\n  action: 'paste',\n  isEdit: true,\n  actionArgs: {\n    after: true,\n    isEdit: true,\n    matchIndent: true\n  }\n}, {\n  keys: '[p',\n  type: 'action',\n  action: 'paste',\n  isEdit: true,\n  actionArgs: {\n    after: false,\n    isEdit: true,\n    matchIndent: true\n  }\n}, {\n  keys: ']<character>',\n  type: 'motion',\n  motion: 'moveToSymbol',\n  motionArgs: {\n    forward: true,\n    toJumplist: true\n  }\n}, {\n  keys: '[<character>',\n  type: 'motion',\n  motion: 'moveToSymbol',\n  motionArgs: {\n    forward: false,\n    toJumplist: true\n  }\n}, {\n  keys: '|',\n  type: 'motion',\n  motion: 'moveToColumn'\n}, {\n  keys: 'o',\n  type: 'motion',\n  motion: 'moveToOtherHighlightedEnd',\n  context: 'visual'\n}, {\n  keys: 'O',\n  type: 'motion',\n  motion: 'moveToOtherHighlightedEnd',\n  motionArgs: {\n    sameLine: true\n  },\n  context: 'visual'\n},\n// Operators\n{\n  keys: 'd',\n  type: 'operator',\n  operator: 'delete'\n}, {\n  keys: 'y',\n  type: 'operator',\n  operator: 'yank'\n}, {\n  keys: 'c',\n  type: 'operator',\n  operator: 'change'\n}, {\n  keys: '>',\n  type: 'operator',\n  operator: 'indent',\n  operatorArgs: {\n    indentRight: true\n  }\n}, {\n  keys: '<',\n  type: 'operator',\n  operator: 'indent',\n  operatorArgs: {\n    indentRight: false\n  }\n}, {\n  keys: 'g~',\n  type: 'operator',\n  operator: 'changeCase'\n}, {\n  keys: 'gu',\n  type: 'operator',\n  operator: 'changeCase',\n  operatorArgs: {\n    toLower: true\n  },\n  isEdit: true\n}, {\n  keys: 'gU',\n  type: 'operator',\n  operator: 'changeCase',\n  operatorArgs: {\n    toLower: false\n  },\n  isEdit: true\n}, {\n  keys: 'n',\n  type: 'motion',\n  motion: 'findNext',\n  motionArgs: {\n    forward: true,\n    toJumplist: true\n  }\n}, {\n  keys: 'N',\n  type: 'motion',\n  motion: 'findNext',\n  motionArgs: {\n    forward: false,\n    toJumplist: true\n  }\n},\n// Operator-Motion dual commands\n{\n  keys: 'x',\n  type: 'operatorMotion',\n  operator: 'delete',\n  motion: 'moveByCharacters',\n  motionArgs: {\n    forward: true\n  },\n  operatorMotionArgs: {\n    visualLine: false\n  }\n}, {\n  keys: 'X',\n  type: 'operatorMotion',\n  operator: 'delete',\n  motion: 'moveByCharacters',\n  motionArgs: {\n    forward: false\n  },\n  operatorMotionArgs: {\n    visualLine: true\n  }\n}, {\n  keys: 'D',\n  type: 'operatorMotion',\n  operator: 'delete',\n  motion: 'moveToEol',\n  motionArgs: {\n    inclusive: true\n  },\n  context: 'normal'\n}, {\n  keys: 'D',\n  type: 'operator',\n  operator: 'delete',\n  operatorArgs: {\n    linewise: true\n  },\n  context: 'visual'\n}, {\n  keys: 'Y',\n  type: 'operatorMotion',\n  operator: 'yank',\n  motion: 'expandToLine',\n  motionArgs: {\n    linewise: true\n  },\n  context: 'normal'\n}, {\n  keys: 'Y',\n  type: 'operator',\n  operator: 'yank',\n  operatorArgs: {\n    linewise: true\n  },\n  context: 'visual'\n}, {\n  keys: 'C',\n  type: 'operatorMotion',\n  operator: 'change',\n  motion: 'moveToEol',\n  motionArgs: {\n    inclusive: true\n  },\n  context: 'normal'\n}, {\n  keys: 'C',\n  type: 'operator',\n  operator: 'change',\n  operatorArgs: {\n    linewise: true\n  },\n  context: 'visual'\n}, {\n  keys: '~',\n  type: 'operatorMotion',\n  operator: 'changeCase',\n  motion: 'moveByCharacters',\n  motionArgs: {\n    forward: true\n  },\n  operatorArgs: {\n    shouldMoveCursor: true\n  },\n  context: 'normal'\n}, {\n  keys: '~',\n  type: 'operator',\n  operator: 'changeCase',\n  context: 'visual'\n}, {\n  keys: '<C-w>',\n  type: 'operatorMotion',\n  operator: 'delete',\n  motion: 'moveByWords',\n  motionArgs: {\n    forward: false,\n    wordEnd: false\n  },\n  context: 'insert'\n},\n// Actions\n{\n  keys: '<C-i>',\n  type: 'action',\n  action: 'jumpListWalk',\n  actionArgs: {\n    forward: true\n  }\n}, {\n  keys: '<C-o>',\n  type: 'action',\n  action: 'jumpListWalk',\n  actionArgs: {\n    forward: false\n  }\n}, {\n  keys: '<C-e>',\n  type: 'action',\n  action: 'scroll',\n  actionArgs: {\n    forward: true,\n    linewise: true\n  }\n}, {\n  keys: '<C-y>',\n  type: 'action',\n  action: 'scroll',\n  actionArgs: {\n    forward: false,\n    linewise: true\n  }\n}, {\n  keys: 'a',\n  type: 'action',\n  action: 'enterInsertMode',\n  isEdit: true,\n  actionArgs: {\n    insertAt: 'charAfter'\n  },\n  context: 'normal'\n}, {\n  keys: 'A',\n  type: 'action',\n  action: 'enterInsertMode',\n  isEdit: true,\n  actionArgs: {\n    insertAt: 'eol'\n  },\n  context: 'normal'\n}, {\n  keys: 'A',\n  type: 'action',\n  action: 'enterInsertMode',\n  isEdit: true,\n  actionArgs: {\n    insertAt: 'endOfSelectedArea'\n  },\n  context: 'visual'\n}, {\n  keys: 'i',\n  type: 'action',\n  action: 'enterInsertMode',\n  isEdit: true,\n  actionArgs: {\n    insertAt: 'inplace'\n  },\n  context: 'normal'\n}, {\n  keys: 'I',\n  type: 'action',\n  action: 'enterInsertMode',\n  isEdit: true,\n  actionArgs: {\n    insertAt: 'firstNonBlank'\n  },\n  context: 'normal'\n}, {\n  keys: 'I',\n  type: 'action',\n  action: 'enterInsertMode',\n  isEdit: true,\n  actionArgs: {\n    insertAt: 'startOfSelectedArea'\n  },\n  context: 'visual'\n}, {\n  keys: 'o',\n  type: 'action',\n  action: 'newLineAndEnterInsertMode',\n  isEdit: true,\n  interlaceInsertRepeat: true,\n  actionArgs: {\n    after: true\n  },\n  context: 'normal'\n}, {\n  keys: 'O',\n  type: 'action',\n  action: 'newLineAndEnterInsertMode',\n  isEdit: true,\n  interlaceInsertRepeat: true,\n  actionArgs: {\n    after: false\n  },\n  context: 'normal'\n}, {\n  keys: 'v',\n  type: 'action',\n  action: 'toggleVisualMode'\n}, {\n  keys: 'V',\n  type: 'action',\n  action: 'toggleVisualMode',\n  actionArgs: {\n    linewise: true\n  }\n}, {\n  keys: '<C-v>',\n  type: 'action',\n  action: 'toggleVisualMode',\n  actionArgs: {\n    blockwise: true\n  }\n}, {\n  keys: '<C-q>',\n  type: 'action',\n  action: 'toggleVisualMode',\n  actionArgs: {\n    blockwise: true\n  }\n}, {\n  keys: 'gv',\n  type: 'action',\n  action: 'reselectLastSelection'\n}, {\n  keys: 'J',\n  type: 'action',\n  action: 'joinLines',\n  isEdit: true\n}, {\n  keys: 'p',\n  type: 'action',\n  action: 'paste',\n  isEdit: true,\n  actionArgs: {\n    after: true,\n    isEdit: true\n  }\n}, {\n  keys: 'P',\n  type: 'action',\n  action: 'paste',\n  isEdit: true,\n  actionArgs: {\n    after: false,\n    isEdit: true\n  }\n}, {\n  keys: 'r<character>',\n  type: 'action',\n  action: 'replace',\n  isEdit: true\n}, {\n  keys: '@<character>',\n  type: 'action',\n  action: 'replayMacro'\n}, {\n  keys: 'q<character>',\n  type: 'action',\n  action: 'enterMacroRecordMode'\n},\n// Handle Replace-mode as a special case of insert mode.\n{\n  keys: 'R',\n  type: 'action',\n  action: 'enterInsertMode',\n  isEdit: true,\n  actionArgs: {\n    replace: true\n  }\n}, {\n  keys: 'u',\n  type: 'action',\n  action: 'undo',\n  context: 'normal'\n}, {\n  keys: 'u',\n  type: 'operator',\n  operator: 'changeCase',\n  operatorArgs: {\n    toLower: true\n  },\n  context: 'visual',\n  isEdit: true\n}, {\n  keys: 'U',\n  type: 'operator',\n  operator: 'changeCase',\n  operatorArgs: {\n    toLower: false\n  },\n  context: 'visual',\n  isEdit: true\n}, {\n  keys: '<C-r>',\n  type: 'action',\n  action: 'redo'\n}, {\n  keys: 'm<character>',\n  type: 'action',\n  action: 'setMark'\n}, {\n  keys: '\"<character>',\n  type: 'action',\n  action: 'setRegister'\n}, {\n  keys: 'zz',\n  type: 'action',\n  action: 'scrollToCursor',\n  actionArgs: {\n    position: 'center'\n  }\n}, {\n  keys: 'z.',\n  type: 'action',\n  action: 'scrollToCursor',\n  actionArgs: {\n    position: 'center'\n  },\n  motion: 'moveToFirstNonWhiteSpaceCharacter'\n}, {\n  keys: 'zt',\n  type: 'action',\n  action: 'scrollToCursor',\n  actionArgs: {\n    position: 'top'\n  }\n}, {\n  keys: 'z<CR>',\n  type: 'action',\n  action: 'scrollToCursor',\n  actionArgs: {\n    position: 'top'\n  },\n  motion: 'moveToFirstNonWhiteSpaceCharacter'\n}, {\n  keys: 'z-',\n  type: 'action',\n  action: 'scrollToCursor',\n  actionArgs: {\n    position: 'bottom'\n  }\n}, {\n  keys: 'zb',\n  type: 'action',\n  action: 'scrollToCursor',\n  actionArgs: {\n    position: 'bottom'\n  },\n  motion: 'moveToFirstNonWhiteSpaceCharacter'\n}, {\n  keys: '.',\n  type: 'action',\n  action: 'repeatLastEdit'\n}, {\n  keys: '<C-a>',\n  type: 'action',\n  action: 'incrementNumberToken',\n  isEdit: true,\n  actionArgs: {\n    increase: true,\n    backtrack: false\n  }\n}, {\n  keys: '<C-x>',\n  type: 'action',\n  action: 'incrementNumberToken',\n  isEdit: true,\n  actionArgs: {\n    increase: false,\n    backtrack: false\n  }\n}, {\n  keys: '<C-t>',\n  type: 'action',\n  action: 'indent',\n  actionArgs: {\n    indentRight: true\n  },\n  context: 'insert'\n}, {\n  keys: '<C-d>',\n  type: 'action',\n  action: 'indent',\n  actionArgs: {\n    indentRight: false\n  },\n  context: 'insert'\n},\n// Text object motions\n{\n  keys: 'a<character>',\n  type: 'motion',\n  motion: 'textObjectManipulation'\n}, {\n  keys: 'i<character>',\n  type: 'motion',\n  motion: 'textObjectManipulation',\n  motionArgs: {\n    textObjectInner: true\n  }\n},\n// Search\n{\n  keys: '/',\n  type: 'search',\n  searchArgs: {\n    forward: true,\n    querySrc: 'prompt',\n    toJumplist: true\n  }\n}, {\n  keys: '?',\n  type: 'search',\n  searchArgs: {\n    forward: false,\n    querySrc: 'prompt',\n    toJumplist: true\n  }\n}, {\n  keys: '*',\n  type: 'search',\n  searchArgs: {\n    forward: true,\n    querySrc: 'wordUnderCursor',\n    wholeWordOnly: true,\n    toJumplist: true\n  }\n}, {\n  keys: '#',\n  type: 'search',\n  searchArgs: {\n    forward: false,\n    querySrc: 'wordUnderCursor',\n    wholeWordOnly: true,\n    toJumplist: true\n  }\n}, {\n  keys: 'g*',\n  type: 'search',\n  searchArgs: {\n    forward: true,\n    querySrc: 'wordUnderCursor',\n    toJumplist: true\n  }\n}, {\n  keys: 'g#',\n  type: 'search',\n  searchArgs: {\n    forward: false,\n    querySrc: 'wordUnderCursor',\n    toJumplist: true\n  }\n},\n// Ex command\n{\n  keys: ':',\n  type: 'ex'\n}];\n\n/**\n * Ex commands\n * Care must be taken when adding to the default Ex command map. For any\n * pair of commands that have a shared prefix, at least one of their\n * shortNames must not match the prefix of the other command.\n */\nvar defaultExCommandMap = [{\n  name: 'colorscheme',\n  shortName: 'colo'\n}, {\n  name: 'map'\n}, {\n  name: 'imap',\n  shortName: 'im'\n}, {\n  name: 'nmap',\n  shortName: 'nm'\n}, {\n  name: 'vmap',\n  shortName: 'vm'\n}, {\n  name: 'unmap'\n}, {\n  name: 'write',\n  shortName: 'w'\n}, {\n  name: 'undo',\n  shortName: 'u'\n}, {\n  name: 'redo',\n  shortName: 'red'\n}, {\n  name: 'set',\n  shortName: 'se'\n}, {\n  name: 'set',\n  shortName: 'se'\n}, {\n  name: 'setlocal',\n  shortName: 'setl'\n}, {\n  name: 'setglobal',\n  shortName: 'setg'\n}, {\n  name: 'sort',\n  shortName: 'sor'\n}, {\n  name: 'substitute',\n  shortName: 's',\n  possiblyAsync: true\n}, {\n  name: 'nohlsearch',\n  shortName: 'noh'\n}, {\n  name: 'yank',\n  shortName: 'y'\n}, {\n  name: 'delmarks',\n  shortName: 'delm'\n}, {\n  name: 'registers',\n  shortName: 'reg',\n  excludeFromCommandHistory: true\n}, {\n  name: 'global',\n  shortName: 'g'\n}];\nvar Pos = _cm_adapter2.default.Pos;\nvar Vim = function Vim() {\n  function enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    _cm_adapter2.default.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    // CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.enterVimMode();\n  }\n  function leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    // CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    cm.leaveVimMode();\n  }\n  function detachVimMap(cm, next) {\n    cm.attached = false;\n    if (this == _cm_adapter2.default.keyMap.vim) {\n      _cm_adapter2.default.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      // if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n      //   disableFatCursorMark(cm);\n      //   cm.getInputField().style.caretColor = \"\";\n      // }\n    }\n    if (!next || next.attach != attachVimMap) leaveVimMode(cm);\n  }\n  function attachVimMap(cm, prev) {\n    if (this == _cm_adapter2.default.keyMap.vim) {\n      cm.attached = true;\n    }\n    if (!prev || prev.attach != attachVimMap) enterVimMode(cm);\n  }\n  function fatCursorMarks(cm) {\n    var ranges = cm.listSelections(),\n      result = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) {\n        if (range.anchor.ch < cm.getLine(range.anchor.line).length) {\n          result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1), {\n            className: \"cm-fat-cursor-mark\"\n          }));\n        } else {\n          var widget = document.createElement(\"span\");\n          widget.textContent = '\\xA0';\n          widget.className = \"cm-fat-cursor-mark\";\n          result.push(cm.setBookmark(range.anchor, {\n            widget: widget\n          }));\n        }\n      }\n    }\n    return result;\n  }\n  function updateFatCursorMark(cm) {\n    var marks = cm.state.fatCursorMarks;\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      marks[i].clear();\n    }\n    cm.state.fatCursorMarks = fatCursorMarks(cm);\n  }\n  function enableFatCursorMark(cm) {\n    cm.state.fatCursorMarks = fatCursorMarks(cm);\n    cm.on(\"cursorActivity\", updateFatCursorMark);\n  }\n  function disableFatCursorMark(cm) {\n    var marks = cm.state.fatCursorMarks;\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      marks[i].clear();\n    }\n    cm.state.fatCursorMarks = null;\n    cm.off(\"cursorActivity\", updateFatCursorMark);\n  }\n\n  // Deprecated, simply setting the keymap works again.\n  _cm_adapter2.default.defineOption('vimMode', false, function (cm, val, prev) {\n    if (val && cm.getOption(\"keyMap\") != \"vim\") cm.setOption(\"keyMap\", \"vim\");else if (!val && prev != _cm_adapter2.default.Init && /^vim/.test(cm.getOption(\"keyMap\"))) cm.setOption(\"keyMap\", \"default\");\n  });\n  function cmKey(key, cm) {\n    if (!cm) {\n      return undefined;\n    }\n    if (this[key]) {\n      return this[key];\n    }\n    var vimKey = cmKeyToVimKey(key);\n    if (!vimKey) {\n      return false;\n    }\n    var cmd = _cm_adapter2.default.Vim.findKey(cm, vimKey);\n    if (typeof cmd == 'function') {\n      _cm_adapter2.default.signal(cm, 'vim-keypress', vimKey);\n    }\n    return cmd;\n  }\n  var modifiers = {\n    'Shift': 'S',\n    'Ctrl': 'C',\n    'Alt': 'A',\n    'Cmd': 'D',\n    'Mod': 'A'\n  };\n  var specialKeys = {\n    Enter: 'CR',\n    Backspace: 'BS',\n    Delete: 'Del',\n    Insert: 'Ins'\n  };\n  function cmKeyToVimKey(key) {\n    if (key.charAt(0) == '\\'') {\n      // Keypress character binding of format \"'a'\"\n      return key.charAt(1);\n    }\n    var pieces = key.split(/-(?!$)/);\n    var lastPiece = pieces[pieces.length - 1];\n    if (pieces.length == 1 && pieces[0].length == 1) {\n      // No-modifier bindings use literal character bindings above. Skip.\n      return false;\n    } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n      // Ignore Shift+char bindings as they should be handled by literal character.\n      return false;\n    }\n    var hasCharacter = false;\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i];\n      if (piece in modifiers) {\n        pieces[i] = modifiers[piece];\n      } else {\n        hasCharacter = true;\n      }\n      if (piece in specialKeys) {\n        pieces[i] = specialKeys[piece];\n      }\n    }\n    if (!hasCharacter) {\n      // Vim does not support modifier only keys.\n      return false;\n    }\n    // TODO: Current bindings expect the character to be lower case, but\n    // it looks like vim key notation uses upper case.\n    if (isUpperCase(lastPiece)) {\n      pieces[pieces.length - 1] = lastPiece.toLowerCase();\n    }\n    return '<' + pieces.join('-') + '>';\n  }\n  function getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n    if (!vim || !vim.onPasteFn) {\n      vim.onPasteFn = function () {\n        if (!vim.insertMode) {\n          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n          actions.enterInsertMode(cm, {}, vim);\n        }\n      };\n    }\n    return vim.onPasteFn;\n  }\n  var numberRegex = /[\\d]/;\n  var wordCharTest = [_cm_adapter2.default.isWordChar, function (ch) {\n      return ch && !_cm_adapter2.default.isWordChar(ch) && !/\\s/.test(ch);\n    }],\n    bigWordCharTest = [function (ch) {\n      return /\\S/.test(ch);\n    }];\n  function makeKeyRange(start, size) {\n    var keys = [];\n    for (var i = start; i < start + size; i++) {\n      keys.push(String.fromCharCode(i));\n    }\n    return keys;\n  }\n  var upperCaseAlphabet = makeKeyRange(65, 26);\n  var lowerCaseAlphabet = makeKeyRange(97, 26);\n  var numbers = makeKeyRange(48, 10);\n  var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n  var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n  function isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n  }\n  function isLowerCase(k) {\n    return /^[a-z]$/.test(k);\n  }\n  function isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n  }\n  function isNumber(k) {\n    return numberRegex.test(k);\n  }\n  function isUpperCase(k) {\n    return /^[A-Z]$/.test(k);\n  }\n  function isWhiteSpaceString(k) {\n    return /^\\s*$/.test(k);\n  }\n  function isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n  }\n  function inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == val) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var options = {};\n  function defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n      throw Error('defaultValue is required unless callback is provided');\n    }\n    if (!type) {\n      type = 'string';\n    }\n    options[name] = {\n      type: type,\n      defaultValue: defaultValue,\n      callback: callback\n    };\n    if (aliases) {\n      for (var i = 0; i < aliases.length; i++) {\n        options[aliases[i]] = options[name];\n      }\n    }\n    if (defaultValue) {\n      setOption(name, defaultValue);\n    }\n  }\n  function setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.type == 'boolean') {\n      if (value && value !== true) {\n        return new Error('Invalid argument: ' + name + '=' + value);\n      } else if (value !== false) {\n        // Boolean options are set to true if value is not defined.\n        value = true;\n      }\n    }\n    if (option.callback) {\n      if (scope !== 'local') {\n        option.callback(value, undefined);\n      }\n      if (scope !== 'global' && cm) {\n        option.callback(value, cm);\n      }\n    } else {\n      if (scope !== 'local') {\n        option.value = option.type == 'boolean' ? !!value : value;\n      }\n      if (scope !== 'global' && cm) {\n        cm.state.vim.options[name] = {\n          value: value\n        };\n      }\n    }\n  }\n  function getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.callback) {\n      var local = cm && option.callback(undefined, cm);\n      if (scope !== 'global' && local !== undefined) {\n        return local;\n      }\n      if (scope !== 'local') {\n        return option.callback();\n      }\n      return;\n    } else {\n      var local = scope !== 'global' && cm && cm.state.vim.options[name];\n      return (local || scope !== 'local' && option || {}).value;\n    }\n  }\n  defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n    // Option is local. Do nothing for global.\n    if (cm === undefined) {\n      return;\n    }\n    // The 'filetype' option proxies to the CodeMirror 'mode' option.\n    if (name === undefined) {\n      var mode = cm.getOption('mode');\n      return mode == 'null' ? '' : mode;\n    } else {\n      var mode = name == '' ? 'null' : name;\n      cm.setOption('mode', mode);\n    }\n  });\n  var createCircularJumpList = function createCircularJumpList() {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n    function add(cm, oldCur, newCur) {\n      var current = pointer % size;\n      var curMark = buffer[current];\n      function useNextSlot(cursor) {\n        var next = ++pointer % size;\n        var trashMark = buffer[next];\n        if (trashMark) {\n          trashMark.clear();\n        }\n        buffer[next] = cm.setBookmark(cursor);\n      }\n      if (curMark) {\n        var markPos = curMark.find();\n        // avoid recording redundant cursor position\n        if (markPos && !cursorEqual(markPos, oldCur)) {\n          useNextSlot(oldCur);\n        }\n      } else {\n        useNextSlot(oldCur);\n      }\n      useNextSlot(newCur);\n      head = pointer;\n      tail = pointer - size + 1;\n      if (tail < 0) {\n        tail = 0;\n      }\n    }\n    function move(cm, offset) {\n      pointer += offset;\n      if (pointer > head) {\n        pointer = head;\n      } else if (pointer < tail) {\n        pointer = tail;\n      }\n      var mark = buffer[(size + pointer) % size];\n      // skip marks that are temporarily removed from text buffer\n      if (mark && !mark.find()) {\n        var inc = offset > 0 ? 1 : -1;\n        var newCur;\n        var oldCur = cm.getCursor();\n        do {\n          pointer += inc;\n          mark = buffer[(size + pointer) % size];\n          // skip marks that are the same as current position\n          if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n            break;\n          }\n        } while (pointer < head && pointer > tail);\n      }\n      return mark;\n    }\n    return {\n      cachedCursor: undefined,\n      //used for # and * jumps\n      add: add,\n      move: move\n    };\n  };\n\n  // Returns an object to track the changes associated insert mode.  It\n  // clones the object that is passed in, or creates an empty object one if\n  // none is provided.\n  var createInsertModeChanges = function createInsertModeChanges(c) {\n    if (c) {\n      // Copy construction\n      return {\n        changes: c.changes,\n        expectCursorActivityForChange: c.expectCursorActivityForChange\n      };\n    }\n    return {\n      // Change list\n      changes: [],\n      // Set to true on change, false on cursorActivity.\n      expectCursorActivityForChange: false\n    };\n  };\n  function MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n  }\n  MacroModeState.prototype = {\n    exitMacroRecordMode: function exitMacroRecordMode() {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.onRecordingDone) {\n        macroModeState.onRecordingDone(); // close dialog\n      }\n      macroModeState.onRecordingDone = undefined;\n      macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function enterMacroRecordMode(cm, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.clear();\n        this.latestRegister = registerName;\n        if (cm.openDialog) {\n          this.onRecordingDone = cm.openDialog('(recording)[' + registerName + ']', null, {\n            bottom: true\n          });\n        }\n        this.isRecording = true;\n      }\n    }\n  };\n  function maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n      // Store instance state in the CodeMirror object.\n      cm.state.vim = {\n        inputState: new InputState(),\n        // Vim's input state that triggered the last edit, used to repeat\n        // motions and operators with '.'.\n        lastEditInputState: undefined,\n        // Vim's action command before the last edit, used to repeat actions\n        // with '.' and insert mode repeat.\n        lastEditActionCommand: undefined,\n        // When using jk for navigation, if you move from a longer line to a\n        // shorter line, the cursor may clip to the end of the shorter line.\n        // If j is pressed again and cursor goes to the next line, the\n        // cursor should go back to its horizontal position on the longer\n        // line if it can. This is to keep track of the horizontal position.\n        lastHPos: -1,\n        // Doing the same with screen-position for gj/gk\n        lastHSPos: -1,\n        // The last motion command run. Cleared if a non-motion command gets\n        // executed in between.\n        lastMotion: null,\n        marks: {},\n        // Mark for rendering fake cursor for visual mode.\n        fakeCursor: null,\n        insertMode: false,\n        // Repeat count for changes made in insert mode, triggered by key\n        // sequences like 3,i. Only exists when insertMode is true.\n        insertModeRepeat: undefined,\n        visualMode: false,\n        // If we are in visual line mode. No effect if visualMode is false.\n        visualLine: false,\n        visualBlock: false,\n        lastSelection: null,\n        lastPastedText: null,\n        sel: {},\n        // Buffer-local/window-local values of vim options.\n        options: {}\n      };\n    }\n    return cm.state.vim;\n  }\n  var vimGlobalState;\n  function resetVimGlobalState() {\n    vimGlobalState = {\n      // The current search query.\n      searchQuery: null,\n      // Whether we are searching backwards.\n      searchIsReversed: false,\n      // Replace part of the last substituted pattern\n      lastSubstituteReplacePart: undefined,\n      jumpList: createCircularJumpList(),\n      macroModeState: new MacroModeState(),\n      // Recording latest f, t, F or T motion command.\n      lastCharacterSearch: {\n        increment: 0,\n        forward: true,\n        selectedCharacter: ''\n      },\n      registerController: new RegisterController({}),\n      // search history buffer\n      searchHistoryController: new HistoryController(),\n      // ex Command history buffer\n      exCommandHistoryController: new HistoryController()\n    };\n    for (var optionName in options) {\n      var option = options[optionName];\n      option.value = option.defaultValue;\n    }\n  }\n  var lastInsertModeKeyTimer;\n  var vimApi = {\n    buildKeyMap: function buildKeyMap() {\n      // TODO: Convert keymap into dictionary format for fast lookup.\n    },\n    // Testing hook, though it might be useful to expose the register\n    // controller anyways.\n    getRegisterController: function getRegisterController() {\n      return vimGlobalState.registerController;\n    },\n    // Testing hook.\n    resetVimGlobalState_: resetVimGlobalState,\n    // Testing hook.\n    getVimGlobalState_: function getVimGlobalState_() {\n      return vimGlobalState;\n    },\n    // Testing hook.\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    map: function map(lhs, rhs, ctx) {\n      // Add user defined key bindings.\n      exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function unmap(lhs, ctx) {\n      exCommandDispatcher.unmap(lhs, ctx);\n    },\n    // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n    // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function defineEx(name, prefix, func) {\n      if (!prefix) {\n        prefix = name;\n      } else if (name.indexOf(prefix) !== 0) {\n        throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n      }\n      exCommands[name] = func;\n      exCommandDispatcher.commandMap_[prefix] = {\n        name: name,\n        shortName: prefix,\n        type: 'api'\n      };\n    },\n    handleKey: function handleKey(cm, key, origin) {\n      var command = this.findKey(cm, key, origin);\n      if (typeof command === 'function') {\n        return command();\n      }\n    },\n    /**\n     * This is the outermost function called by CodeMirror, after keys have\n     * been mapped to their Vim equivalents.\n     *\n     * Finds a command based on the key (and cached keys if there is a\n     * multi-key sequence). Returns `undefined` if no key is matched, a noop\n     * function if a partial match is found (multi-key), and a function to\n     * execute the bound command if a a key is matched. The function always\n     * returns true.\n     */\n    findKey: function findKey(cm, key, origin) {\n      var vim = maybeInitVimState(cm);\n      function handleMacroRecording() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          if (key == 'q') {\n            macroModeState.exitMacroRecordMode();\n            clearInputState(cm);\n            return true;\n          }\n          if (origin != 'mapping') {\n            logKey(macroModeState, key);\n          }\n        }\n      }\n      function handleEsc() {\n        if (key == '<Esc>') {\n          // Clear input state and get back to normal mode.\n          clearInputState(cm);\n          if (vim.visualMode) {\n            exitVisualMode(cm);\n          } else if (vim.insertMode) {\n            exitInsertMode(cm);\n          }\n          return true;\n        }\n      }\n      function doKeyToKey(keys) {\n        // TODO: prevent infinite recursion.\n        var match;\n        while (keys) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = /<\\w+-.+?>|<\\w+>|./.exec(keys);\n          key = match[0];\n          keys = keys.substring(match.index + key.length);\n          _cm_adapter2.default.Vim.handleKey(cm, key, 'mapping');\n        }\n      }\n      function handleKeyInsertMode() {\n        if (handleEsc()) {\n          return true;\n        }\n        var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n        var keysAreChars = key.length == 1;\n        var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n        // Need to check all key substrings in insert mode.\n        while (keys.length > 1 && match.type != 'full') {\n          var keys = vim.inputState.keyBuffer = keys.slice(1);\n          var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          if (thisMatch.type != 'none') {\n            match = thisMatch;\n          }\n        }\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n          lastInsertModeKeyTimer = window.setTimeout(function () {\n            if (vim.insertMode && vim.inputState.keyBuffer) {\n              clearInputState(cm);\n            }\n          }, getOption('insertModeEscKeysTimeout'));\n          return !keysAreChars;\n        }\n        if (lastInsertModeKeyTimer) {\n          window.clearTimeout(lastInsertModeKeyTimer);\n        }\n        if (keysAreChars) {\n          var selections = cm.listSelections();\n          for (var i = 0; i < selections.length; i++) {\n            var here = selections[i].head;\n            cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n          }\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n        }\n        clearInputState(cm);\n        return match.command;\n      }\n      function handleKeyNonInsertMode() {\n        if (handleMacroRecording() || handleEsc()) {\n          return true;\n        }\n        var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n        if (/^[1-9]\\d*$/.test(keys)) {\n          return true;\n        }\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (!keysMatcher) {\n          clearInputState(cm);\n          return false;\n        }\n        var context = vim.visualMode ? 'visual' : 'normal';\n        var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          return true;\n        }\n        vim.inputState.keyBuffer = '';\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (keysMatcher[1] && keysMatcher[1] != '0') {\n          vim.inputState.pushRepeatDigit(keysMatcher[1]);\n        }\n        return match.command;\n      }\n      var command;\n      if (vim.insertMode) {\n        command = handleKeyInsertMode();\n      } else {\n        command = handleKeyNonInsertMode();\n      }\n      if (command === false) {\n        return !vim.insertMode && key.length === 1 ? function () {\n          return true;\n        } : undefined;\n      } else if (command === true) {\n        // TODO: Look into using CodeMirror's multi-key handling.\n        // Return no-op since we are caching the key. Counts as handled, but\n        // don't want act on it just yet.\n        return function () {\n          return true;\n        };\n      } else {\n        return function () {\n          return cm.operation(function () {\n            cm.curOp.isVimOp = true;\n            try {\n              if (command.type == 'keyToKey') {\n                doKeyToKey(command.toKeys);\n              } else {\n                commandDispatcher.processCommand(cm, vim, command);\n              }\n            } catch (e) {\n              // clear VIM state in case it's in a bad state.\n              cm.state.vim = undefined;\n              maybeInitVimState(cm);\n              if (!_cm_adapter2.default.Vim.suppressErrorLogging) {\n                console['log'](e);\n              }\n              throw e;\n            }\n            return true;\n          });\n        };\n      }\n    },\n    handleEx: function handleEx(cm, input) {\n      exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n  };\n\n  // Represents the current input state.\n  function InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n    this.registerName = null; // Defaults to the unnamed register.\n  }\n  InputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n      this.prefixRepeat = this.prefixRepeat.concat(n);\n    } else {\n      this.motionRepeat = this.motionRepeat.concat(n);\n    }\n  };\n  InputState.prototype.getRepeat = function () {\n    var repeat = 0;\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n      repeat = 1;\n      if (this.prefixRepeat.length > 0) {\n        repeat *= parseInt(this.prefixRepeat.join(''), 10);\n      }\n      if (this.motionRepeat.length > 0) {\n        repeat *= parseInt(this.motionRepeat.join(''), 10);\n      }\n    }\n    return repeat;\n  };\n  function clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    _cm_adapter2.default.signal(cm, 'vim-command-done', reason);\n  }\n\n  /*\n   * Register stores information about copy and paste registers.  Besides\n   * text, a register must store whether it is linewise (i.e., when it is\n   * pasted, should it insert itself into a new line, or should the text be\n   * inserted at the cursor position.)\n   */\n  function Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || ''];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n  }\n  Register.prototype = {\n    setText: function setText(text, linewise, blockwise) {\n      this.keyBuffer = [text || ''];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    },\n    pushText: function pushText(text, linewise) {\n      // if this register has ever been set to linewise, use linewise.\n      if (linewise) {\n        if (!this.linewise) {\n          this.keyBuffer.push('\\n');\n        }\n        this.linewise = true;\n      }\n      this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function pushInsertModeChanges(changes) {\n      this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function pushSearchQuery(query) {\n      this.searchQueries.push(query);\n    },\n    clear: function clear() {\n      this.keyBuffer = [];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = false;\n    },\n    toString: function toString() {\n      return this.keyBuffer.join('');\n    }\n  };\n\n  /**\n   * Defines an external register.\n   *\n   * The name should be a single character that will be used to reference the register.\n   * The register should support setText, pushText, clear, and toString(). See Register\n   * for a reference implementation.\n   */\n  function defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n      throw Error('Register name must be 1 character');\n    }\n    if (registers[name]) {\n      throw Error('Register already defined ' + name);\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n  }\n\n  /*\n   * vim registers allow you to keep many independent copy and paste buffers.\n   * See http://usevim.com/2012/04/13/registers/ for an introduction.\n   *\n   * RegisterController keeps the state of all the registers.  An initial\n   * state may be passed in.  The unnamed register '\"' will always be\n   * overridden.\n   */\n  function RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers['.'] = new Register();\n    registers[':'] = new Register();\n    registers['/'] = new Register();\n  }\n  RegisterController.prototype = {\n    pushText: function pushText(registerName, operator, text, linewise, blockwise) {\n      if (linewise && text.charAt(text.length - 1) !== '\\n') {\n        text += '\\n';\n      }\n      // Lowercase and uppercase registers refer to the same register.\n      // Uppercase just means append.\n      var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;\n      // if no register/an invalid register was specified, things go to the\n      // default registers\n      if (!register) {\n        switch (operator) {\n          case 'yank':\n            // The 0 register contains the text from the most recent yank.\n            this.registers['0'] = new Register(text, linewise, blockwise);\n            break;\n          case 'delete':\n          case 'change':\n            if (text.indexOf('\\n') == -1) {\n              // Delete less than 1 line. Update the small delete register.\n              this.registers['-'] = new Register(text, linewise);\n            } else {\n              // Shift down the contents of the numbered registers and put the\n              // deleted text into register 1.\n              this.shiftNumericRegisters_();\n              this.registers['1'] = new Register(text, linewise);\n            }\n            break;\n        }\n        // Make sure the unnamed register is set to what just happened\n        this.unnamedRegister.setText(text, linewise, blockwise);\n        return;\n      }\n\n      // If we've gotten to this point, we've actually specified a register\n      var append = isUpperCase(registerName);\n      if (append) {\n        register.pushText(text, linewise);\n      } else {\n        register.setText(text, linewise, blockwise);\n      }\n      // The unnamed register always has the same value as the last used\n      // register.\n      this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    // Gets the register named @name.  If one of @name doesn't already exist,\n    // create it.  If @name is invalid, return the unnamedRegister.\n    getRegister: function getRegister(name) {\n      if (!this.isValidRegister(name)) {\n        return this.unnamedRegister;\n      }\n      name = name.toLowerCase();\n      if (!this.registers[name]) {\n        this.registers[name] = new Register();\n      }\n      return this.registers[name];\n    },\n    isValidRegister: function isValidRegister(name) {\n      return name && inArray(name, validRegisters);\n    },\n    shiftNumericRegisters_: function shiftNumericRegisters_() {\n      for (var i = 9; i >= 2; i--) {\n        this.registers[i] = this.getRegister('' + (i - 1));\n      }\n    }\n  };\n  function HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n  }\n  HistoryController.prototype = {\n    // the input argument here acts a user entered prefix for a small time\n    // until we start autocompletion in which case it is the autocompleted.\n    nextMatch: function nextMatch(input, up) {\n      var historyBuffer = this.historyBuffer;\n      var dir = up ? -1 : 1;\n      if (this.initialPrefix === null) this.initialPrefix = input;\n      for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n        var element = historyBuffer[i];\n        for (var j = 0; j <= element.length; j++) {\n          if (this.initialPrefix == element.substring(0, j)) {\n            this.iterator = i;\n            return element;\n          }\n        }\n      }\n      // should return the user input in case we reach the end of buffer.\n      if (i >= historyBuffer.length) {\n        this.iterator = historyBuffer.length;\n        return this.initialPrefix;\n      }\n      // return the last autocompleted query or exCommand as it is.\n      if (i < 0) return input;\n    },\n    pushInput: function pushInput(input) {\n      var index = this.historyBuffer.indexOf(input);\n      if (index > -1) this.historyBuffer.splice(index, 1);\n      if (input.length) this.historyBuffer.push(input);\n    },\n    reset: function reset() {\n      this.initialPrefix = null;\n      this.iterator = this.historyBuffer.length;\n    }\n  };\n  var commandDispatcher = {\n    matchCommand: function matchCommand(keys, keyMap, inputState, context) {\n      var matches = commandMatches(keys, keyMap, context, inputState);\n      if (!matches.full && !matches.partial) {\n        return {\n          type: 'none'\n        };\n      } else if (!matches.full && matches.partial) {\n        return {\n          type: 'partial'\n        };\n      }\n      var bestMatch;\n      for (var i = 0; i < matches.full.length; i++) {\n        var match = matches.full[i];\n        if (!bestMatch) {\n          bestMatch = match;\n        }\n      }\n      if (bestMatch.keys.slice(-11) == '<character>') {\n        var character = lastChar(keys);\n        if (!character) return {\n          type: 'none'\n        };\n        inputState.selectedCharacter = character;\n      }\n      return {\n        type: 'full',\n        command: bestMatch\n      };\n    },\n    processCommand: function processCommand(cm, vim, command) {\n      vim.inputState.repeatOverride = command.repeatOverride;\n      switch (command.type) {\n        case 'motion':\n          this.processMotion(cm, vim, command);\n          break;\n        case 'operator':\n          this.processOperator(cm, vim, command);\n          // cm.pushUndoStop();\n          break;\n        case 'operatorMotion':\n          this.processOperatorMotion(cm, vim, command);\n          // cm.pushUndoStop();\n          break;\n        case 'action':\n          this.processAction(cm, vim, command);\n          break;\n        case 'search':\n          this.processSearch(cm, vim, command);\n          break;\n        case 'ex':\n        case 'keyToEx':\n          this.processEx(cm, vim, command);\n          break;\n        default:\n          break;\n      }\n    },\n    processMotion: function processMotion(cm, vim, command) {\n      vim.inputState.motion = command.motion;\n      vim.inputState.motionArgs = copyArgs(command.motionArgs);\n      this.evalInput(cm, vim);\n    },\n    processOperator: function processOperator(cm, vim, command) {\n      var inputState = vim.inputState;\n      if (inputState.operator) {\n        if (inputState.operator == command.operator) {\n          // Typing an operator twice like 'dd' makes the operator operate\n          // linewise\n          inputState.motion = 'expandToLine';\n          inputState.motionArgs = {\n            linewise: true\n          };\n          this.evalInput(cm, vim);\n          return;\n        } else {\n          // 2 different operators in a row doesn't make sense.\n          clearInputState(cm);\n        }\n      }\n      inputState.operator = command.operator;\n      inputState.operatorArgs = copyArgs(command.operatorArgs);\n      if (vim.visualMode) {\n        // Operating on a selection in visual mode. We don't need a motion.\n        this.evalInput(cm, vim);\n      }\n    },\n    processOperatorMotion: function processOperatorMotion(cm, vim, command) {\n      var visualMode = vim.visualMode;\n      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n      if (operatorMotionArgs) {\n        // Operator motions may have special behavior in visual mode.\n        if (visualMode && operatorMotionArgs.visualLine) {\n          vim.visualLine = true;\n        }\n      }\n      this.processOperator(cm, vim, command);\n      if (!visualMode) {\n        this.processMotion(cm, vim, command);\n      }\n    },\n    processAction: function processAction(cm, vim, command) {\n      var inputState = vim.inputState;\n      var repeat = inputState.getRepeat();\n      var repeatIsExplicit = !!repeat;\n      var actionArgs = copyArgs(command.actionArgs) || {};\n      if (inputState.selectedCharacter) {\n        actionArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      // Actions may or may not have motions and operators. Do these first.\n      if (command.operator) {\n        this.processOperator(cm, vim, command);\n      }\n      if (command.motion) {\n        this.processMotion(cm, vim, command);\n      }\n      if (command.motion || command.operator) {\n        this.evalInput(cm, vim);\n      }\n      actionArgs.repeat = repeat || 1;\n      actionArgs.repeatIsExplicit = repeatIsExplicit;\n      actionArgs.registerName = inputState.registerName;\n      clearInputState(cm);\n      vim.lastMotion = null;\n      if (command.isEdit) {\n        this.recordLastEdit(vim, inputState, command);\n      }\n      actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function processSearch(cm, vim, command) {\n      if (!cm.getSearchCursor) {\n        // Search depends on SearchCursor.\n        return;\n      }\n      var forward = command.searchArgs.forward;\n      var wholeWordOnly = command.searchArgs.wholeWordOnly;\n      getSearchState(cm).setReversed(!forward);\n      var promptPrefix = forward ? '/' : '?';\n      var originalQuery = getSearchState(cm).getQuery();\n      var originalScrollPos = cm.getScrollInfo();\n      function handleQuery(query, ignoreCase, smartCase) {\n        vimGlobalState.searchHistoryController.pushInput(query);\n        vimGlobalState.searchHistoryController.reset();\n        try {\n          updateSearchQuery(cm, query, ignoreCase, smartCase);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + query);\n          clearInputState(cm);\n          return;\n        }\n        commandDispatcher.processMotion(cm, vim, {\n          type: 'motion',\n          motion: 'findNext',\n          motionArgs: {\n            forward: true,\n            toJumplist: command.searchArgs.toJumplist\n          }\n        });\n      }\n      function onPromptClose(query) {\n        cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          logSearchQuery(macroModeState, query);\n        }\n      }\n      function onPromptKeyUp(e, query, close) {\n        var keyName = _cm_adapter2.default.keyName(e),\n          up,\n          offset;\n        if (keyName == 'Up' || keyName == 'Down') {\n          up = keyName == 'Up' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n          close(query);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else {\n          if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.searchHistoryController.reset();\n        }\n        var parsedQuery;\n        try {\n          parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          // Swallow bad regexes for incremental search.\n        }\n        if (parsedQuery) {\n          cm.scrollIntoView(_findNext(cm, !forward, parsedQuery), 30);\n        } else {\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        }\n      }\n      function onPromptKeyDown(e, query, close) {\n        var keyName = _cm_adapter2.default.keyName(e);\n        if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && query == '') {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          updateSearchQuery(cm, originalQuery);\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          _cm_adapter2.default.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        } else if (keyName == 'Up' || keyName == 'Down') {\n          _cm_adapter2.default.e_stop(e);\n        } else if (keyName == 'Ctrl-U') {\n          // Ctrl-U clears input.\n          _cm_adapter2.default.e_stop(e);\n          close('');\n        }\n      }\n      switch (command.searchArgs.querySrc) {\n        case 'prompt':\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isPlaying) {\n            var query = macroModeState.replaySearchQueries.shift();\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: promptPrefix,\n              desc: searchPromptDesc,\n              onKeyUp: onPromptKeyUp,\n              onKeyDown: onPromptKeyDown\n            });\n          }\n          break;\n        case 'wordUnderCursor':\n          var word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, true /** noSymbol */);\n          var isKeyword = true;\n          if (!word) {\n            word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, false /** noSymbol */);\n            isKeyword = false;\n          }\n          if (!word) {\n            return;\n          }\n          var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n          if (isKeyword && wholeWordOnly) {\n            query = '\\\\b' + query + '\\\\b';\n          } else {\n            query = escapeRegex(query);\n          }\n\n          // cachedCursor is used to save the old position of the cursor\n          // when * or # causes vim to seek for the nearest word and shift\n          // the cursor before entering the motion.\n          vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n          cm.setCursor(word.start);\n          handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          break;\n      }\n    },\n    processEx: function processEx(cm, vim, command) {\n      function onPromptClose(input) {\n        // Give the prompt some time to close so that if processCommand shows\n        // an error, the elements don't overlap.\n        vimGlobalState.exCommandHistoryController.pushInput(input);\n        vimGlobalState.exCommandHistoryController.reset();\n        exCommandDispatcher.processCommand(cm, input);\n      }\n      function onPromptKeyDown(e, input, close) {\n        var keyName = _cm_adapter2.default.keyName(e),\n          up,\n          offset;\n        if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && input == '') {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          _cm_adapter2.default.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        }\n        if (keyName == 'Up' || keyName == 'Down') {\n          _cm_adapter2.default.e_stop(e);\n          up = keyName == 'Up' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n          close(input);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName == 'Ctrl-U') {\n          // Ctrl-U clears input.\n          _cm_adapter2.default.e_stop(e);\n          close('');\n        } else {\n          if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.exCommandHistoryController.reset();\n        }\n      }\n      if (command.type == 'keyToEx') {\n        // Handle user defined Ex to Ex mappings\n        exCommandDispatcher.processCommand(cm, command.exArgs.input);\n      } else {\n        if (vim.visualMode) {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            value: '\\'<,\\'>',\n            onKeyDown: onPromptKeyDown,\n            selectValueOnOpen: false\n          });\n        } else {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            onKeyDown: onPromptKeyDown\n          });\n        }\n      }\n    },\n    evalInput: function evalInput(cm, vim) {\n      // If the motion command is set, execute both the operator and motion.\n      // Otherwise return.\n      var inputState = vim.inputState;\n      var motion = inputState.motion;\n      var motionArgs = inputState.motionArgs || {};\n      var operator = inputState.operator;\n      var operatorArgs = inputState.operatorArgs || {};\n      var registerName = inputState.registerName;\n      var sel = vim.sel;\n      // TODO: Make sure cm and vim selections are identical outside visual mode.\n      var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n      var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n      var oldHead = copyCursor(origHead);\n      var oldAnchor = copyCursor(origAnchor);\n      var newHead, newAnchor;\n      var repeat;\n      if (operator) {\n        this.recordLastEdit(vim, inputState);\n      }\n      if (inputState.repeatOverride !== undefined) {\n        // If repeatOverride is specified, that takes precedence over the\n        // input state's repeat. Used by Ex mode and can be user defined.\n        repeat = inputState.repeatOverride;\n      } else {\n        repeat = inputState.getRepeat();\n      }\n      if (repeat > 0 && motionArgs.explicitRepeat) {\n        motionArgs.repeatIsExplicit = true;\n      } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n        repeat = 1;\n        motionArgs.repeatIsExplicit = false;\n      }\n      if (inputState.selectedCharacter) {\n        // If there is a character input, stick it in all of the arg arrays.\n        motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      motionArgs.repeat = repeat;\n      clearInputState(cm);\n      if (motion) {\n        var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n        vim.lastMotion = motions[motion];\n        if (!motionResult) {\n          return;\n        }\n        if (motionArgs.toJumplist) {\n          var jumpList = vimGlobalState.jumpList;\n          // if the current motion is # or *, use cachedCursor\n          var cachedCursor = jumpList.cachedCursor;\n          if (cachedCursor) {\n            recordJumpPosition(cm, cachedCursor, motionResult);\n            delete jumpList.cachedCursor;\n          } else {\n            recordJumpPosition(cm, origHead, motionResult);\n          }\n        }\n        if (motionResult instanceof Array) {\n          newAnchor = motionResult[0];\n          newHead = motionResult[1];\n        } else {\n          newHead = motionResult;\n        }\n        // TODO: Handle null returns from motion commands better.\n        if (!newHead) {\n          newHead = copyCursor(origHead);\n        }\n        if (vim.visualMode) {\n          if (!(vim.visualBlock && newHead.ch === Infinity)) {\n            newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n          }\n          if (newAnchor) {\n            newAnchor = clipCursorToContent(cm, newAnchor, true);\n          }\n          newAnchor = newAnchor || oldAnchor;\n          sel.anchor = newAnchor;\n          sel.head = newHead;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n          updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n        } else if (!operator) {\n          newHead = clipCursorToContent(cm, newHead);\n          cm.setCursor(newHead.line, newHead.ch);\n        }\n      }\n      if (operator) {\n        if (operatorArgs.lastSel) {\n          // Replaying a visual mode operation\n          newAnchor = oldAnchor;\n          var lastSel = operatorArgs.lastSel;\n          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n          if (lastSel.visualLine) {\n            // Linewise Visual mode: The same number of lines.\n            newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          } else if (lastSel.visualBlock) {\n            // Blockwise Visual mode: The same number of lines and columns.\n            newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n          } else if (lastSel.head.line == lastSel.anchor.line) {\n            // Normal Visual mode within one line: The same number of characters.\n            newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n          } else {\n            // Normal Visual mode with several lines: The same number of lines, in the\n            // last line the same number of characters as in the last line the last time.\n            newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          }\n          vim.visualMode = true;\n          vim.visualLine = lastSel.visualLine;\n          vim.visualBlock = lastSel.visualBlock;\n          sel = vim.sel = {\n            anchor: newAnchor,\n            head: newHead\n          };\n          updateCmSelection(cm);\n        } else if (vim.visualMode) {\n          operatorArgs.lastSel = {\n            anchor: copyCursor(sel.anchor),\n            head: copyCursor(sel.head),\n            visualBlock: vim.visualBlock,\n            visualLine: vim.visualLine\n          };\n        }\n        var curStart, curEnd, linewise, mode;\n        var cmSel;\n        if (vim.visualMode) {\n          // Init visual op\n          curStart = cursorMin(sel.head, sel.anchor);\n          curEnd = cursorMax(sel.head, sel.anchor);\n          linewise = vim.visualLine || operatorArgs.linewise;\n          mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';\n          cmSel = makeCmSelection(cm, {\n            anchor: curStart,\n            head: curEnd\n          }, mode);\n          if (linewise) {\n            var ranges = cmSel.ranges;\n            if (mode == 'block') {\n              // Linewise operators in visual block mode extend to end of line\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n              }\n            } else if (mode == 'line') {\n              ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n            }\n          }\n        } else {\n          // Init motion op\n          curStart = copyCursor(newAnchor || oldAnchor);\n          curEnd = copyCursor(newHead || oldHead);\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n          }\n          linewise = motionArgs.linewise || operatorArgs.linewise;\n          if (linewise) {\n            // Expand selection to entire line.\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            // Clip to trailing newlines only if the motion goes forward.\n            clipToLine(cm, curStart, curEnd);\n          }\n          mode = 'char';\n          var exclusive = !motionArgs.inclusive || linewise;\n          cmSel = makeCmSelection(cm, {\n            anchor: curStart,\n            head: curEnd\n          }, mode, exclusive);\n        }\n        cm.setSelections(cmSel.ranges, cmSel.primary);\n        vim.lastMotion = null;\n        operatorArgs.repeat = repeat; // For indent in visual mode.\n        operatorArgs.registerName = registerName;\n        // Keep track of linewise as it affects how paste and change behave.\n        operatorArgs.linewise = linewise;\n        var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n        if (vim.visualMode) {\n          exitVisualMode(cm, operatorMoveTo != null);\n        }\n        if (operatorMoveTo) {\n          cm.setCursor(operatorMoveTo);\n        }\n      }\n    },\n    recordLastEdit: function recordLastEdit(vim, inputState, actionCommand) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      vim.lastEditInputState = inputState;\n      vim.lastEditActionCommand = actionCommand;\n      macroModeState.lastInsertModeChanges.changes = [];\n      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n    }\n  };\n\n  /**\n   * typedef {Object{line:number,ch:number}} Cursor An object containing the\n   *     position of the cursor.\n   */\n  // All of the functions below return Cursor objects.\n  var motions = {\n    moveToTopLine: function moveToTopLine(cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n      return Pos(line, cm.findFirstNonWhiteSpaceCharacter(line));\n    },\n    moveToMiddleLine: function moveToMiddleLine(cm) {\n      var range = getUserVisibleLines(cm);\n      var line = Math.floor((range.top + range.bottom) * 0.5);\n      return Pos(line, cm.findFirstNonWhiteSpaceCharacter(line));\n    },\n    moveToBottomLine: function moveToBottomLine(cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n      return Pos(line, cm.findFirstNonWhiteSpaceCharacter(line));\n    },\n    expandToLine: function expandToLine(_cm, head, motionArgs) {\n      // Expands forward to end of line, and then to next line if repeat is\n      // >1. Does not handle backward motion!\n      var cur = head;\n      return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function findNext(cm, _head, motionArgs) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      // If search is initiated with ? instead of /, negate direction.\n      prev = state.isReversed() ? !prev : prev;\n      highlightSearchMatches(cm, query);\n      return _findNext(cm, prev /** prev */, query, motionArgs.repeat);\n    },\n    goToMark: function goToMark(cm, _head, motionArgs, vim) {\n      var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n      if (pos) {\n        return motionArgs.linewise ? {\n          line: pos.line,\n          ch: cm.findFirstNonWhiteSpaceCharacter(pos.line)\n        } : pos;\n      }\n      return null;\n    },\n    moveToOtherHighlightedEnd: function moveToOtherHighlightedEnd(cm, _head, motionArgs, vim) {\n      if (vim.visualBlock && motionArgs.sameLine) {\n        var sel = vim.sel;\n        return [clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))];\n      } else {\n        return [vim.sel.head, vim.sel.anchor];\n      }\n    },\n    jumpToMark: function jumpToMark(cm, head, motionArgs, vim) {\n      var best = head;\n      for (var i = 0; i < motionArgs.repeat; i++) {\n        var cursor = best;\n        for (var key in vim.marks) {\n          if (!isLowerCase(key)) {\n            continue;\n          }\n          var mark = vim.marks[key].find();\n          var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n          if (isWrongDirection) {\n            continue;\n          }\n          if (motionArgs.linewise && mark.line == cursor.line) {\n            continue;\n          }\n          var equal = cursorEqual(cursor, best);\n          var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);\n          if (equal || between) {\n            best = mark;\n          }\n        }\n      }\n      if (motionArgs.linewise) {\n        // Vim places the cursor on the first non-whitespace character of\n        // the line if there is one, else it places the cursor at the end\n        // of the line, regardless of whether a mark was found.\n        best = Pos(best.line, cm.findFirstNonWhiteSpaceCharacter(best.line));\n      }\n      return best;\n    },\n    moveByCharacters: function moveByCharacters(_cm, head, motionArgs) {\n      var cur = head;\n      var repeat = motionArgs.repeat;\n      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n      return Pos(cur.line, ch);\n    },\n    moveByLines: function moveByLines(cm, head, motionArgs, vim) {\n      var cur = head;\n      var endCh = cur.ch;\n      // Depending what our last motion was, we may want to do different\n      // things. If our last motion was moving vertically, we want to\n      // preserve the HPos from our last horizontal move.  If our last motion\n      // was going to the end of a line, moving vertically we should go to\n      // the end of the line, etc.\n      switch (vim.lastMotion) {\n        case this.moveByLines:\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveToColumn:\n        case this.moveToEol:\n          endCh = vim.lastHPos;\n          break;\n        default:\n          vim.lastHPos = endCh;\n      }\n      var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n      var first = cm.firstLine();\n      var last = cm.lastLine();\n      // Vim go to line begin or line end when cursor at first/last line and\n      // move to previous/next line is triggered.\n      if (line < first && cur.line == first) {\n        return this.moveToStartOfLine(cm, head, motionArgs, vim);\n      } else if (line > last && cur.line == last) {\n        return this.moveToEol(cm, head, motionArgs, vim);\n      }\n      if (motionArgs.toFirstChar) {\n        endCh = cm.findFirstNonWhiteSpaceCharacter(line);\n        vim.lastHPos = endCh;\n      }\n      vim.lastHSPos = cm.charCoords(Pos(line, endCh), 'div').left;\n      return Pos(line, endCh);\n    },\n    moveByDisplayLines: function moveByDisplayLines(cm, head, motionArgs, vim) {\n      var cur = head;\n      switch (vim.lastMotion) {\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveByLines:\n        case this.moveToColumn:\n        case this.moveToEol:\n          break;\n        default:\n          vim.lastHSPos = cm.charCoords(cur, 'div').left;\n      }\n      var repeat = motionArgs.repeat;\n      var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n      if (res.hitSide) {\n        if (motionArgs.forward) {\n          var lastCharCoords = cm.charCoords(res, 'div');\n          var goalCoords = {\n            top: lastCharCoords.top + 8,\n            left: vim.lastHSPos\n          };\n          var res = cm.coordsChar(goalCoords, 'div');\n        } else {\n          var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n          resCoords.left = vim.lastHSPos;\n          res = cm.coordsChar(resCoords, 'div');\n        }\n      }\n      vim.lastHPos = res.ch;\n      return res;\n    },\n    moveByPage: function moveByPage(cm, head, motionArgs) {\n      // CodeMirror only exposes functions that move the cursor page down, so\n      // doing this bad hack to move the cursor and move it back. evalInput\n      // will move the cursor to where it should be in the end.\n      var curStart = head;\n      var repeat = motionArgs.repeat;\n      return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');\n    },\n    moveByParagraph: function moveByParagraph(cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function moveBySentence(cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function moveByScroll(cm, head, motionArgs, vim) {\n      var scrollbox = cm.getScrollInfo();\n      var curEnd = null;\n      var repeat = motionArgs.repeat;\n      if (!repeat) {\n        repeat = Math.floor(scrollbox.clientHeight / (2 * cm.defaultTextHeight()));\n      }\n      var orig = cm.charCoords(head, 'local');\n      motionArgs.repeat = repeat;\n      var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n      if (!curEnd) {\n        return null;\n      }\n      var dest = cm.charCoords(curEnd, 'local');\n      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n      return curEnd;\n    },\n    moveByWords: function moveByWords(cm, head, motionArgs) {\n      return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function moveTillCharacter(cm, _head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      var curEnd = _moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);\n      var increment = motionArgs.forward ? -1 : 1;\n      recordLastCharacterSearch(increment, motionArgs);\n      if (!curEnd) return null;\n      curEnd.ch += increment;\n      return curEnd;\n    },\n    moveToCharacter: function moveToCharacter(cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      recordLastCharacterSearch(0, motionArgs);\n      return _moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToSymbol: function moveToSymbol(cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function moveToColumn(cm, head, motionArgs, vim) {\n      var repeat = motionArgs.repeat;\n      // repeat is equivalent to which column we want to move to!\n      vim.lastHPos = repeat - 1;\n      vim.lastHSPos = cm.charCoords(head, 'div').left;\n      return _moveToColumn(cm, repeat);\n    },\n    moveToEol: function moveToEol(cm, head, motionArgs, vim) {\n      var cur = head;\n      vim.lastHPos = Infinity;\n      var retval = Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end = cm.clipPos(retval);\n      end.ch--;\n      vim.lastHSPos = cm.charCoords(end, 'div').left;\n      return retval;\n    },\n    moveToFirstNonWhiteSpaceCharacter: function moveToFirstNonWhiteSpaceCharacter(cm, head) {\n      // Go to the start of the line where the text begins, or the end for\n      // whitespace-only lines\n      var cursor = head;\n      return Pos(cursor.line, cm.findFirstNonWhiteSpaceCharacter(cursor.line));\n    },\n    moveToMatchedSymbol: function moveToMatchedSymbol(cm, head) {\n      var cursor = head;\n      var line = cursor.line;\n      var ch = cursor.ch;\n      var lineText = cm.getLine(line);\n      // var symbol;\n      // for (; ch < lineText.length; ch++) {\n      //   symbol = lineText.charAt(ch);\n      //   if (symbol && isMatchableSymbol(symbol)) {\n      //     var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n      //     if (style !== \"string\" && style !== \"comment\") {\n      //       break;\n      //     }\n      //   }\n      // }\n      if (ch < lineText.length) {\n        var matched = cm.findMatchingBracket(Pos(line, ch));\n        return matched.to;\n      } else {\n        return cursor;\n      }\n    },\n    moveToStartOfLine: function moveToStartOfLine(_cm, head) {\n      return Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function moveToLineOrEdgeOfDocument(cm, _head, motionArgs) {\n      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n      if (motionArgs.repeatIsExplicit) {\n        lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n      }\n      return Pos(lineNum, cm.findFirstNonWhiteSpaceCharacter(lineNum));\n    },\n    textObjectManipulation: function textObjectManipulation(cm, head, motionArgs, vim) {\n      // TODO: lots of possible exceptions that can be thrown here. Try da(\n      //     outside of a () block.\n\n      // TODO: adding <> >< to this map doesn't work, presumably because\n      // they're operators\n      var mirroredPairs = {\n        '(': ')',\n        ')': '(',\n        '{': '}',\n        '}': '{',\n        '[': ']',\n        ']': '['\n      };\n      var selfPaired = {\n        '\\'': true,\n        '\"': true\n      };\n      var character = motionArgs.selectedCharacter;\n      // 'b' refers to  '()' block.\n      // 'B' refers to  '{}' block.\n      if (character == 'b') {\n        character = '(';\n      } else if (character == 'B') {\n        character = '{';\n      }\n\n      // Inclusive is the difference between a and i\n      // TODO: Instead of using the additional text object map to perform text\n      //     object operations, merge the map into the defaultKeyMap and use\n      //     motionArgs to define behavior. Define separate entries for 'aw',\n      //     'iw', 'a[', 'i[', etc.\n      var inclusive = !motionArgs.textObjectInner;\n      var tmp;\n      if (mirroredPairs[character]) {\n        tmp = selectCompanionObject(cm, head, character, inclusive);\n      } else if (selfPaired[character]) {\n        tmp = findBeginningAndEnd(cm, head, character, inclusive);\n      } else if (character === 'W') {\n        tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, true /** bigWord */);\n      } else if (character === 'w') {\n        tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, false /** bigWord */);\n      } else if (character === 'p') {\n        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n        motionArgs.linewise = true;\n        if (vim.visualMode) {\n          if (!vim.visualLine) {\n            vim.visualLine = true;\n          }\n        } else {\n          var operatorArgs = vim.inputState.operatorArgs;\n          if (operatorArgs) {\n            operatorArgs.linewise = true;\n          }\n          tmp.end.line--;\n        }\n      } else {\n        // No text object defined for this, don't move.\n        return null;\n      }\n      if (!cm.state.vim.visualMode) {\n        return [tmp.start, tmp.end];\n      } else {\n        return expandSelection(cm, tmp.start, tmp.end);\n      }\n    },\n    repeatLastCharacterSearch: function repeatLastCharacterSearch(cm, head, motionArgs) {\n      var lastSearch = vimGlobalState.lastCharacterSearch;\n      var repeat = motionArgs.repeat;\n      var forward = motionArgs.forward === lastSearch.forward;\n      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n      cm.moveH(-1 * increment, 'char');\n      motionArgs.inclusive = forward ? true : false;\n      var curEnd = _moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n      if (!curEnd) {\n        cm.moveH(increment, 'char');\n        return head;\n      }\n      curEnd.ch += increment;\n      return curEnd;\n    }\n  };\n  function defineMotion(name, fn) {\n    motions[name] = fn;\n  }\n  function fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n      arr.push(val);\n    }\n    return arr;\n  }\n  /**\n   * An operator acts on a text selection. It receives the list of selections\n   * as input. The corresponding CodeMirror selection is guaranteed to\n  * match the input selection.\n   */\n  var operators = {\n    change: function change(cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock;\n      if (!vim.visualMode) {\n        var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n        text = cm.getRange(anchor, head);\n        var lastState = vim.lastEditInputState || {};\n        if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n          // Exclude trailing whitespace if the range is not all whitespace.\n          var match = /\\s+$/.exec(text);\n          if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n            head = offsetCursor(head, 0, -match[0].length);\n            text = text.slice(0, -match[0].length);\n          }\n        }\n        var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n        var wasLastLine = cm.firstLine() == cm.lastLine();\n        if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n          cm.replaceRange('', prevLineEnd, head);\n        } else {\n          cm.replaceRange('', anchor, head);\n        }\n        if (args.linewise) {\n          // Push the next line back down, if there is a next line.\n          if (!wasLastLine) {\n            cm.setCursor(prevLineEnd);\n            _cm_adapter2.default.commands.newlineAndIndent(cm);\n          }\n          // make sure cursor ends up at the end of the line.\n          anchor.ch = Number.MAX_VALUE;\n        }\n        finalHead = anchor;\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n      actions.enterInsertMode(cm, {\n        head: finalHead\n      }, cm.state.vim);\n    },\n    // delete is a javascript keyword.\n    'delete': function _delete(cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      if (!vim.visualBlock) {\n        var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n        if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n          // Special case for dd on last line (and first line).\n          if (anchor.line == cm.firstLine()) {\n            anchor.ch = 0;\n          } else {\n            anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n          }\n        }\n        text = cm.getRange(anchor, head);\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n        if (args.linewise) {\n          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n        }\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = ranges[0].anchor;\n      }\n      vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n      var includeLineBreak = vim.insertMode;\n      return clipCursorToContent(cm, finalHead, includeLineBreak);\n    },\n    indent: function indent(cm, args, ranges) {\n      var vim = cm.state.vim;\n      var startLine = ranges[0].anchor.line;\n      var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;\n      // In visual mode, n> shifts the selection right n times, instead of\n      // shifting n lines right once.\n      var repeat = vim.visualMode ? args.repeat : 1;\n      if (args.linewise) {\n        // The only way to delete a newline is to delete until the start of\n        // the next line, so in linewise mode evalInput will include the next\n        // line. We don't want this in indent, so we go back a line.\n        endLine--;\n      }\n      cm.pushUndoStop();\n      for (var i = startLine; i <= endLine; i++) {\n        for (var j = 0; j < repeat; j++) {\n          cm.indentLine(i, args.indentRight);\n        }\n      }\n      cm.pushUndoStop();\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    changeCase: function changeCase(cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      var toLower = args.toLower;\n      for (var j = 0; j < selections.length; j++) {\n        var toSwap = selections[j];\n        var text = '';\n        if (toLower === true) {\n          text = toSwap.toLowerCase();\n        } else if (toLower === false) {\n          text = toSwap.toUpperCase();\n        } else {\n          for (var i = 0; i < toSwap.length; i++) {\n            var character = toSwap.charAt(i);\n            text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n          }\n        }\n        swapped.push(text);\n      }\n      cm.replaceSelections(swapped);\n      if (args.shouldMoveCursor) {\n        return newHead;\n      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise) {\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n    yank: function yank(cm, args, ranges, oldAnchor) {\n      var vim = cm.state.vim;\n      var text = cm.getSelection();\n      var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n      vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n      return endPos;\n    }\n  };\n  function defineOperator(name, fn) {\n    operators[name] = fn;\n  }\n  var actions = {\n    jumpListWalk: function jumpListWalk(cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      var forward = actionArgs.forward;\n      var jumpList = vimGlobalState.jumpList;\n      var mark = jumpList.move(cm, forward ? repeat : -repeat);\n      var markPos = mark ? mark.find() : undefined;\n      markPos = markPos ? markPos : cm.getCursor();\n      cm.setCursor(markPos);\n    },\n    scroll: function scroll(cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat || 1;\n      var lineHeight = cm.defaultTextHeight();\n      var top = cm.getScrollInfo().top;\n      var delta = lineHeight * repeat;\n      var newPos = actionArgs.forward ? top + delta : top - delta;\n      var cursor = copyCursor(cm.getCursor());\n      var cursorCoords = cm.charCoords(cursor, 'local');\n      if (actionArgs.forward) {\n        if (newPos > cursorCoords.top) {\n          cursor.line += (newPos - cursorCoords.top) / lineHeight;\n          cursor.line = Math.ceil(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.top);\n        } else {\n          // Cursor stays within bounds.  Just reposition the scroll window.\n          cm.scrollTo(null, newPos);\n        }\n      } else {\n        var newBottom = newPos + cm.getScrollInfo().clientHeight;\n        if (newBottom < cursorCoords.bottom) {\n          cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n          cursor.line = Math.floor(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n        } else {\n          // Cursor stays within bounds.  Just reposition the scroll window.\n          cm.scrollTo(null, newPos);\n        }\n      }\n    },\n    scrollToCursor: function scrollToCursor(cm, actionArgs) {\n      // var lineNum = cm.getCursor().line;\n      // var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n      // var height = cm.getScrollInfo().clientHeight;\n      // var y = charCoords.top;\n      // var lineHeight = charCoords.bottom - y;\n      // switch (actionArgs.position) {\n      //   case 'center': y = y - (height / 2) + lineHeight;\n      //     break;\n      //   case 'bottom': y = y - height + lineHeight;\n      //     break;\n      // }\n      // cm.scrollTo(null, y);\n      cm.moveCurrentLineTo(actionArgs.position);\n    },\n    replayMacro: function replayMacro(cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var repeat = actionArgs.repeat;\n      var macroModeState = vimGlobalState.macroModeState;\n      if (registerName == '@') {\n        registerName = macroModeState.latestRegister;\n      }\n      while (repeat--) {\n        executeMacroRegister(cm, vim, macroModeState, registerName);\n      }\n    },\n    enterMacroRecordMode: function enterMacroRecordMode(cm, actionArgs) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var registerName = actionArgs.selectedCharacter;\n      if (vimGlobalState.registerController.isValidRegister(registerName)) {\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      }\n    },\n    toggleOverwrite: function toggleOverwrite(cm) {\n      if (!cm.state.overwrite) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        _cm_adapter2.default.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        _cm_adapter2.default.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n    },\n    enterInsertMode: function enterInsertMode(cm, actionArgs, vim) {\n      if (cm.getOption('readOnly')) {\n        return;\n      }\n      vim.insertMode = true;\n      vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n      cm.leaveVimMode();\n      var insertAt = actionArgs ? actionArgs.insertAt : null;\n      var sel = vim.sel;\n      var head = actionArgs.head || cm.getCursor('head');\n      var height = cm.listSelections().length;\n      if (insertAt == 'eol') {\n        head = Pos(head.line, lineLength(cm, head.line));\n      } else if (insertAt == 'charAfter') {\n        head = offsetCursor(head, 0, 1);\n      } else if (insertAt == 'firstNonBlank') {\n        head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n      } else if (insertAt == 'startOfSelectedArea') {\n        if (!vim.visualBlock) {\n          if (sel.head.line < sel.anchor.line) {\n            head = sel.head;\n          } else {\n            head = Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'endOfSelectedArea') {\n        if (!vim.visualBlock) {\n          if (sel.head.line >= sel.anchor.line) {\n            head = offsetCursor(sel.head, 0, 1);\n          } else {\n            head = Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch + 1, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'inplace') {\n        if (vim.visualMode) {\n          return;\n        }\n      }\n      cm.setOption('disableInput', false);\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      if (actionArgs && actionArgs.replace) {\n        // Handle Replace-mode as a special case of insert mode.\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        _cm_adapter2.default.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        _cm_adapter2.default.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n      if (!vimGlobalState.macroModeState.isPlaying) {\n        // Only record if not replaying.\n        cm.on('change', onChange);\n        _cm_adapter2.default.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function toggleVisualMode(cm, actionArgs, vim) {\n      var repeat = actionArgs.repeat;\n      var anchor = cm.getCursor();\n      var head;\n      // TODO: The repeat should actually select number of characters/lines\n      //     equal to the repeat times the size of the previous visual\n      //     operation.\n      if (!vim.visualMode) {\n        // Entering visual mode\n        vim.visualMode = true;\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        head = clipCursorToContent(cm, Pos(anchor.line, anchor.ch + repeat - 1), true /** includeLineBreak */);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        _cm_adapter2.default.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n      } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {\n        // Toggling between modes\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        _cm_adapter2.default.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n      } else {\n        exitVisualMode(cm);\n      }\n    },\n    reselectLastSelection: function reselectLastSelection(cm, _actionArgs, vim) {\n      var lastSelection = vim.lastSelection;\n      if (vim.visualMode) {\n        updateLastSelection(cm, vim);\n      }\n      if (lastSelection) {\n        var anchor = lastSelection.anchorMark.find();\n        var head = lastSelection.headMark.find();\n        if (!anchor || !head) {\n          // If the marks have been destroyed due to edits, do nothing.\n          return;\n        }\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        vim.visualMode = true;\n        vim.visualLine = lastSelection.visualLine;\n        vim.visualBlock = lastSelection.visualBlock;\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n        _cm_adapter2.default.signal(cm, 'vim-mode-change', {\n          mode: 'visual',\n          subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''\n        });\n      }\n    },\n    joinLines: function joinLines(cm, actionArgs, vim) {\n      var curStart, curEnd;\n      if (vim.visualMode) {\n        curStart = cm.getCursor('anchor');\n        curEnd = cm.getCursor('head');\n        if (cursorIsBefore(curEnd, curStart)) {\n          var tmp = curEnd;\n          curEnd = curStart;\n          curStart = tmp;\n        }\n        curEnd.ch = lineLength(cm, curEnd.line) - 1;\n      } else {\n        // Repeat is the number of lines to join. Minimum 2 lines.\n        var repeat = Math.max(actionArgs.repeat, 2);\n        curStart = cm.getCursor();\n        curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1, Infinity));\n      }\n      var finalCh = 0;\n      for (var i = curStart.line; i < curEnd.line; i++) {\n        finalCh = lineLength(cm, curStart.line);\n        var tmp = Pos(curStart.line + 1, lineLength(cm, curStart.line + 1));\n        var text = cm.getRange(curStart, tmp);\n        text = text.replace(/\\n\\s*/g, ' ');\n        cm.replaceRange(text, curStart, tmp);\n      }\n      var curFinalPos = Pos(curStart.line, finalCh);\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function newLineAndEnterInsertMode(cm, actionArgs, vim) {\n      vim.insertMode = true;\n      var insertAt = copyCursor(cm.getCursor());\n      if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n        // Special case for inserting newline before start of document.\n        cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n        cm.setCursor(cm.firstLine(), 0);\n      } else {\n        insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n        insertAt.ch = lineLength(cm, insertAt.line);\n        cm.setCursor(insertAt);\n        var newlineFn = _cm_adapter2.default.commands.newlineAndIndentContinueComment || _cm_adapter2.default.commands.newlineAndIndent;\n        newlineFn(cm);\n      }\n      this.enterInsertMode(cm, {\n        repeat: actionArgs.repeat\n      }, vim);\n    },\n    paste: function paste(cm, actionArgs, vim) {\n      var cur = copyCursor(cm.getCursor());\n      var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n      var text = register.toString();\n      if (!text) {\n        return;\n      }\n      if (actionArgs.matchIndent) {\n        var tabSize = cm.getOption(\"tabSize\");\n        // length that considers tabs and tabSize\n        var whitespaceLength = function whitespaceLength(str) {\n          var tabs = str.split(\"\\t\").length - 1;\n          var spaces = str.split(\" \").length - 1;\n          return tabs * tabSize + spaces * 1;\n        };\n        var currentLine = cm.getLine(cm.getCursor().line);\n        var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n        // chomp last newline b/c don't want it to match /^\\s*/gm\n        var chompedText = text.replace(/\\n$/, '');\n        var wasChomped = text !== chompedText;\n        var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n        var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n          if (newIndent < 0) {\n            return \"\";\n          } else if (cm.getOption(\"indentWithTabs\")) {\n            var quotient = Math.floor(newIndent / tabSize);\n            return Array(quotient + 1).join('\\t');\n          } else {\n            return Array(newIndent + 1).join(' ');\n          }\n        });\n        text += wasChomped ? \"\\n\" : \"\";\n      }\n      if (actionArgs.repeat > 1) {\n        var text = Array(actionArgs.repeat + 1).join(text);\n      }\n      var linewise = register.linewise;\n      var blockwise = register.blockwise;\n      if (linewise) {\n        if (vim.visualMode) {\n          text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n        } else if (actionArgs.after) {\n          // Move the newline at the end to the start instead, and paste just\n          // before the newline character of the line we are on right now.\n          text = '\\n' + text.slice(0, text.length - 1);\n          cur.ch = lineLength(cm, cur.line);\n        } else {\n          cur.ch = 0;\n        }\n      } else {\n        if (blockwise) {\n          text = text.split('\\n');\n          for (var i = 0; i < text.length; i++) {\n            text[i] = text[i] == '' ? ' ' : text[i];\n          }\n        }\n        cur.ch += actionArgs.after ? 1 : 0;\n      }\n      var curPosFinal;\n      var idx;\n      if (vim.visualMode) {\n        //  save the pasted text for reselection if the need arises\n        vim.lastPastedText = text;\n        var lastSelectionCurEnd;\n        var selectedArea = getSelectedAreaRange(cm, vim);\n        var selectionStart = selectedArea[0];\n        var selectionEnd = selectedArea[1];\n        var selectedText = cm.getSelection();\n        var selections = cm.listSelections();\n        var emptyStrings = new Array(selections.length).join('1').split('1');\n        // save the curEnd marker before it get cleared due to cm.replaceRange.\n        if (vim.lastSelection) {\n          lastSelectionCurEnd = vim.lastSelection.headMark.find();\n        }\n        // push the previously selected text to unnamed register\n        vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n        if (blockwise) {\n          // first delete the selected text\n          cm.replaceSelections(emptyStrings);\n          // Set new selections as per the block length of the yanked text\n          selectionEnd = Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n          cm.setCursor(selectionStart);\n          selectBlock(cm, selectionEnd);\n          cm.replaceSelections(text);\n          curPosFinal = selectionStart;\n        } else if (vim.visualBlock) {\n          cm.replaceSelections(emptyStrings);\n          cm.setCursor(selectionStart);\n          cm.replaceRange(text, selectionStart, selectionStart);\n          curPosFinal = selectionStart;\n        } else {\n          cm.replaceRange(text, selectionStart, selectionEnd);\n          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n        }\n        // restore the the curEnd marker\n        if (lastSelectionCurEnd) {\n          vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n        }\n        if (linewise) {\n          curPosFinal.ch = 0;\n        }\n      } else {\n        if (blockwise) {\n          cm.setCursor(cur);\n          for (var i = 0; i < text.length; i++) {\n            var line = cur.line + i;\n            if (line > cm.lastLine()) {\n              cm.replaceRange('\\n', Pos(line, 0));\n            }\n            var lastCh = lineLength(cm, line);\n            if (lastCh < cur.ch) {\n              extendLineToColumn(cm, line, cur.ch);\n            }\n          }\n          cm.setCursor(cur);\n          selectBlock(cm, Pos(cur.line + text.length - 1, cur.ch));\n          cm.replaceSelections(text);\n          curPosFinal = cur;\n        } else {\n          cm.replaceRange(text, cur);\n          // Now fine tune the cursor to where we want it.\n          if (linewise && actionArgs.after) {\n            curPosFinal = Pos(cur.line + 1, cm.findFirstNonWhiteSpaceCharacter(cur.line + 1));\n          } else if (linewise && !actionArgs.after) {\n            curPosFinal = Pos(cur.line, cm.findFirstNonWhiteSpaceCharacter(cur.line));\n          } else if (!linewise && actionArgs.after) {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length - 1);\n          } else {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length);\n          }\n        }\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curPosFinal);\n    },\n    undo: function undo(cm, actionArgs) {\n      cm.operation(function () {\n        repeatFn(cm, _cm_adapter2.default.commands.undo, actionArgs.repeat)();\n        cm.setCursor(cm.getCursor('anchor'));\n      });\n    },\n    redo: function redo(cm, actionArgs) {\n      repeatFn(cm, _cm_adapter2.default.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function setRegister(_cm, actionArgs, vim) {\n      vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    setMark: function setMark(cm, actionArgs, vim) {\n      var markName = actionArgs.selectedCharacter;\n      updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function replace(cm, actionArgs, vim) {\n      var replaceWith = actionArgs.selectedCharacter;\n      var curStart = cm.getCursor();\n      var replaceTo;\n      var curEnd;\n      var selections = cm.listSelections();\n      if (vim.visualMode) {\n        curStart = cm.getCursor('start');\n        curEnd = cm.getCursor('end');\n      } else {\n        var line = cm.getLine(curStart.line);\n        replaceTo = curStart.ch + actionArgs.repeat;\n        if (replaceTo > line.length) {\n          replaceTo = line.length;\n        }\n        curEnd = Pos(curStart.line, replaceTo);\n      }\n      if (replaceWith == '\\n') {\n        if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n        // special case, where vim help says to replace by just one line-break\n        (_cm_adapter2.default.commands.newlineAndIndentContinueComment || _cm_adapter2.default.commands.newlineAndIndent)(cm);\n      } else {\n        var replaceWithStr = cm.getRange(curStart, curEnd);\n        //replace all characters in range by selected, but keep linebreaks\n        replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n        if (vim.visualBlock) {\n          // Tabs are split in visua block before replacing\n          var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n          replaceWithStr = cm.getSelection();\n          replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n          cm.replaceSelections(replaceWithStr);\n        } else {\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n        }\n        if (vim.visualMode) {\n          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n          cm.setCursor(curStart);\n          exitVisualMode(cm, false);\n        } else {\n          cm.setCursor(offsetCursor(curEnd, 0, -1));\n        }\n      }\n    },\n    incrementNumberToken: function incrementNumberToken(cm, actionArgs) {\n      var cur = cm.getCursor();\n      var lineStr = cm.getLine(cur.line);\n      var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n      var match;\n      var start;\n      var end;\n      var numberStr;\n      while ((match = re.exec(lineStr)) !== null) {\n        start = match.index;\n        end = start + match[0].length;\n        if (cur.ch < end) break;\n      }\n      if (!actionArgs.backtrack && end <= cur.ch) return;\n      if (match) {\n        var baseStr = match[2] || match[4];\n        var digits = match[3] || match[5];\n        var increment = actionArgs.increase ? 1 : -1;\n        var base = {\n          '0b': 2,\n          '0': 8,\n          '': 10,\n          '0x': 16\n        }[baseStr.toLowerCase()];\n        var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n        numberStr = number.toString(base);\n        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n        if (numberStr.charAt(0) === '-') {\n          numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n        } else {\n          numberStr = baseStr + zeroPadding + numberStr;\n        }\n        var from = Pos(cur.line, start);\n        var to = Pos(cur.line, end);\n        cm.replaceRange(numberStr, from, to);\n      } else {\n        return;\n      }\n      cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function repeatLastEdit(cm, actionArgs, vim) {\n      var lastEditInputState = vim.lastEditInputState;\n      if (!lastEditInputState) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      if (repeat && actionArgs.repeatIsExplicit) {\n        vim.lastEditInputState.repeatOverride = repeat;\n      } else {\n        repeat = vim.lastEditInputState.repeatOverride || repeat;\n      }\n      _repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n    indent: function indent(cm, actionArgs) {\n      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode\n  };\n  function defineAction(name, fn) {\n    actions[name] = fn;\n  }\n\n  /*\n   * Below are miscellaneous utility functions used by vim.js\n   */\n\n  /**\n   * Clips cursor to ensure that line is within the buffer's range\n   * If includeLineBreak is true, then allow cur.ch == lineLength.\n   */\n  function clipCursorToContent(cm, cur, includeLineBreak) {\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var maxCh = lineLength(cm, line) - 1;\n    maxCh = includeLineBreak ? maxCh + 1 : maxCh;\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    return Pos(line, ch);\n  }\n  function copyArgs(args) {\n    var ret = {};\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        ret[prop] = args[prop];\n      }\n    }\n    return ret;\n  }\n  function offsetCursor(cur, offsetLine, offsetCh) {\n    if ((typeof offsetLine === 'undefined' ? 'undefined' : _typeof(offsetLine)) === 'object') {\n      offsetCh = offsetLine.ch;\n      offsetLine = offsetLine.line;\n    }\n    return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n  }\n  function getOffset(anchor, head) {\n    return {\n      line: head.line - anchor.line,\n      ch: head.line - anchor.line\n    };\n  }\n  function commandMatches(keys, keyMap, context, inputState) {\n    // Partial matches are not applied. They inform the key handler\n    // that the current key sequence is a subsequence of a valid key\n    // sequence, so that the key buffer is not cleared.\n    var match,\n      partial = [],\n      full = [];\n    for (var i = 0; i < keyMap.length; i++) {\n      var command = keyMap[i];\n      if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {\n        continue;\n      }\n      if (match == 'partial') {\n        partial.push(command);\n      }\n      if (match == 'full') {\n        full.push(command);\n      }\n    }\n    return {\n      partial: partial.length && partial,\n      full: full.length && full\n    };\n  }\n  function commandMatch(pressed, mapped) {\n    if (mapped.slice(-11) == '<character>') {\n      // Last character matches anything.\n      var prefixLen = mapped.length - 11;\n      var pressedPrefix = pressed.slice(0, prefixLen);\n      var mappedPrefix = mapped.slice(0, prefixLen);\n      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    } else {\n      return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n  }\n  function lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1) {\n      switch (selectedCharacter) {\n        case '<CR>':\n          selectedCharacter = '\\n';\n          break;\n        case '<Space>':\n          selectedCharacter = ' ';\n          break;\n        default:\n          selectedCharacter = '';\n          break;\n      }\n    }\n    return selectedCharacter;\n  }\n  function repeatFn(cm, fn, repeat) {\n    return function () {\n      for (var i = 0; i < repeat; i++) {\n        fn(cm);\n      }\n    };\n  }\n  function copyCursor(cur) {\n    return Pos(cur.line, cur.ch);\n  }\n  function cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n  }\n  function cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n      return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n      return true;\n    }\n    return false;\n  }\n  function cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n  }\n  function cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n  }\n  function cursorIsBetween(cur1, cur2, cur3) {\n    // returns true if cur2 is between cur1 and cur3.\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n  }\n  function lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n  }\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, '');\n  }\n  function escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n  }\n  function extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(' ');\n    cm.setCursor(Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n  }\n  // This functions selects a rectangular block\n  // of text with selectionEnd as any of its corner\n  // Height of block:\n  // Difference in selectionEnd.line and first/last selection.line\n  // Width of the block:\n  // Distance between selectionEnd.ch and any(first considered here) selection.ch\n  function selectBlock(cm, selectionEnd) {\n    var selections = [],\n      ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch,\n      headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n      baseCh++;\n      if (!isClipped) {\n        headCh--;\n      }\n    } else if (dir < 0 && newDir >= 0) {\n      baseCh--;\n      if (!wasClipped) {\n        headCh++;\n      }\n    } else if (dir < 0 && newDir == -1) {\n      baseCh--;\n      headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n      var range = {\n        anchor: new Pos(line, baseCh),\n        head: new Pos(line, headCh)\n      };\n      selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n  }\n  function selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n      var lineHead = offsetCursor(head, i, 0);\n      sel.push({\n        anchor: lineHead,\n        head: lineHead\n      });\n    }\n    cm.setSelections(sel, 0);\n  }\n  // getIndex returns the index of the cursor in the selections.\n  function getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n      var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n      var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n      if (atAnchor || atHead) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  function getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n    var getCurrentSelectedAreaRange = function getCurrentSelectedAreaRange() {\n      var selections = cm.listSelections();\n      var start = selections[0];\n      var end = selections[selections.length - 1];\n      var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n      var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n      return [selectionStart, selectionEnd];\n    };\n    var getLastSelectedAreaRange = function getLastSelectedAreaRange() {\n      var selectionStart = cm.getCursor();\n      var selectionEnd = cm.getCursor();\n      var block = lastSelection.visualBlock;\n      if (block) {\n        var width = block.width;\n        var height = block.height;\n        selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n        var selections = [];\n        // selectBlock creates a 'proper' rectangular block.\n        // We do not want that in all cases, so we manually set selections.\n        for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n          var anchor = Pos(i, selectionStart.ch);\n          var head = Pos(i, selectionEnd.ch);\n          var range = {\n            anchor: anchor,\n            head: head\n          };\n          selections.push(range);\n        }\n        cm.setSelections(selections);\n      } else {\n        var start = lastSelection.anchorMark.find();\n        var end = lastSelection.headMark.find();\n        var line = end.line - start.line;\n        var ch = end.ch - start.ch;\n        selectionEnd = {\n          line: selectionEnd.line + line,\n          ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n        };\n        if (lastSelection.visualLine) {\n          selectionStart = Pos(selectionStart.line, 0);\n          selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n        }\n        cm.setSelection(selectionStart, selectionEnd);\n      }\n      return [selectionStart, selectionEnd];\n    };\n    if (!vim.visualMode) {\n      // In case of replaying the action.\n      return getLastSelectedAreaRange();\n    } else {\n      return getCurrentSelectedAreaRange();\n    }\n  }\n  // Updates the previous selection with the current selection's values. This\n  // should only be called in visual mode.\n  function updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    // To accommodate the effect of lastPastedText in the last selection\n    if (vim.lastPastedText) {\n      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n      vim.lastPastedText = null;\n    }\n    vim.lastSelection = {\n      'anchorMark': cm.setBookmark(anchor),\n      'headMark': cm.setBookmark(head),\n      'anchor': copyCursor(anchor),\n      'head': copyCursor(head),\n      'visualMode': vim.visualMode,\n      'visualLine': vim.visualLine,\n      'visualBlock': vim.visualBlock\n    };\n  }\n  function expandSelection(cm, start, end) {\n    var sel = cm.state.vim.sel;\n    var head = sel.head;\n    var anchor = sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n      tmp = end;\n      end = start;\n      start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n      head = cursorMin(start, head);\n      anchor = cursorMax(anchor, end);\n    } else {\n      anchor = cursorMin(start, anchor);\n      head = cursorMax(head, end);\n      head = offsetCursor(head, 0, -1);\n      if (head.ch == -1 && head.line != cm.firstLine()) {\n        head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n      }\n    }\n    return [anchor, head];\n  }\n  /**\n   * Updates the CodeMirror selection to match the provided vim selection.\n   * If no arguments are given, it uses the current vim selection state.\n   */\n  function updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode = mode || vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n    updateFakeCursor(cm);\n  }\n  function makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == 'char') {\n      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      head = offsetCursor(sel.head, 0, headOffset);\n      anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'line') {\n      if (!cursorIsBefore(sel.head, sel.anchor)) {\n        anchor.ch = 0;\n        var lastLine = cm.lastLine();\n        if (head.line > lastLine) {\n          head.line = lastLine;\n        }\n        head.ch = lineLength(cm, head.line);\n      } else {\n        head.ch = 0;\n        anchor.ch = lineLength(cm, anchor.line);\n      }\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'block') {\n      var top = Math.min(anchor.line, head.line),\n        left = Math.min(anchor.ch, head.ch),\n        bottom = Math.max(anchor.line, head.line),\n        right = Math.max(anchor.ch, head.ch) + 1;\n      var height = bottom - top + 1;\n      var primary = head.line == top ? 0 : height - 1;\n      var ranges = [];\n      for (var i = 0; i < height; i++) {\n        ranges.push({\n          anchor: Pos(top + i, left),\n          head: Pos(top + i, right)\n        });\n      }\n      return {\n        ranges: ranges,\n        primary: primary\n      };\n    }\n  }\n  function getHead(cm) {\n    var cur = cm.getCursor('head');\n    if (cm.getSelection().length == 1) {\n      // Small corner case when only 1 character is selected. The \"real\"\n      // head is the left of head and anchor.\n      cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n    return cur;\n  }\n\n  /**\n   * If moveHead is set to false, the CodeMirror selection will not be\n   * touched. The caller assumes the responsibility of putting the cursor\n  * in the right place.\n   */\n  function exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n      cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    _cm_adapter2.default.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    if (vim.fakeCursor) {\n      vim.fakeCursor.clear();\n    }\n  }\n\n  // Remove any trailing newlines from the selection. For\n  // example, with the caret at the start of the last word on the line,\n  // 'dw' should word, but not the newline, while 'w' should advance the\n  // caret to the first character of the next line.\n  function clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    // Only clip if the selection ends with trailing newline + whitespace\n    if (/\\n\\s*$/.test(selection)) {\n      var lines = selection.split('\\n');\n      // We know this is all whitespace.\n      lines.pop();\n\n      // Cases:\n      // 1. Last word is an empty line - do not clip the trailing '\\n'\n      // 2. Last word is not an empty line - clip the trailing '\\n'\n      var line;\n      // Find the line containing the last word, and clip all whitespace up\n      // to it.\n      for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n        curEnd.line--;\n        curEnd.ch = 0;\n      }\n      // If the last word is not an empty line, clip an additional newline\n      if (line) {\n        curEnd.line--;\n        curEnd.ch = lineLength(cm, curEnd.line);\n      } else {\n        curEnd.ch = 0;\n      }\n    }\n  }\n\n  // Expand the selection to line ends.\n  function expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n  }\n\n  // function findFirstNonWhiteSpaceCharacter(text) {\n  //   if (!text) {\n  //     return 0;\n  //   }\n  //   var firstNonWS = text.search(/\\S/);\n  //   return firstNonWS == -1 ? text.length : firstNonWS;\n  // }\n\n  function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n    var cur = getHead(cm);\n    var line = cm.getLine(cur.line);\n    var idx = cur.ch;\n\n    // Seek to first word or non-whitespace character, depending on if\n    // noSymbol is true.\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n    while (!test(line.charAt(idx))) {\n      idx++;\n      if (idx >= line.length) {\n        return null;\n      }\n    }\n    if (bigWord) {\n      test = bigWordCharTest[0];\n    } else {\n      test = wordCharTest[0];\n      if (!test(line.charAt(idx))) {\n        test = wordCharTest[1];\n      }\n    }\n    var end = idx,\n      start = idx;\n    while (test(line.charAt(end)) && end < line.length) {\n      end++;\n    }\n    while (test(line.charAt(start)) && start >= 0) {\n      start--;\n    }\n    start++;\n    if (inclusive) {\n      // If present, include all whitespace after word.\n      // Otherwise, include all whitespace before word, except indentation.\n      var wordEnd = end;\n      while (/\\s/.test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n      if (wordEnd == end) {\n        var wordStart = start;\n        while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n          start--;\n        }\n        if (!start) {\n          start = wordStart;\n        }\n      }\n    }\n    return {\n      start: Pos(cur.line, start),\n      end: Pos(cur.line, end)\n    };\n  }\n  function recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n      vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n  }\n  function recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n  }\n  var symbolToMode = {\n    '(': 'bracket',\n    ')': 'bracket',\n    '{': 'bracket',\n    '}': 'bracket',\n    '[': 'section',\n    ']': 'section',\n    '*': 'comment',\n    '/': 'comment',\n    'm': 'method',\n    'M': 'method',\n    '#': 'preprocess'\n  };\n  var findSymbolModes = {\n    bracket: {\n      isComplete: function isComplete(state) {\n        if (state.nextCh === state.symb) {\n          state.depth++;\n          if (state.depth >= 1) return true;\n        } else if (state.nextCh === state.reverseSymb) {\n          state.depth--;\n        }\n        return false;\n      }\n    },\n    section: {\n      init: function init(state) {\n        state.curMoveThrough = true;\n        state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n      },\n      isComplete: function isComplete(state) {\n        return state.index === 0 && state.nextCh === state.symb;\n      }\n    },\n    comment: {\n      isComplete: function isComplete(state) {\n        var found = state.lastCh === '*' && state.nextCh === '/';\n        state.lastCh = state.nextCh;\n        return found;\n      }\n    },\n    // TODO: The original Vim implementation only operates on level 1 and 2.\n    // The current implementation doesn't check for code block level and\n    // therefore it operates on any levels.\n    method: {\n      init: function init(state) {\n        state.symb = state.symb === 'm' ? '{' : '}';\n        state.reverseSymb = state.symb === '{' ? '}' : '{';\n      },\n      isComplete: function isComplete(state) {\n        if (state.nextCh === state.symb) return true;\n        return false;\n      }\n    },\n    preprocess: {\n      init: function init(state) {\n        state.index = 0;\n      },\n      isComplete: function isComplete(state) {\n        if (state.nextCh === '#') {\n          var token = state.lineText.match(/#(\\w+)/)[1];\n          if (token === 'endif') {\n            if (state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth++;\n          } else if (token === 'if') {\n            if (!state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth--;\n          }\n          if (token === 'else' && state.depth === 0) return true;\n        }\n        return false;\n      }\n    }\n  };\n  function findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n      lineText: lineText,\n      nextCh: lineText.charAt(curCh),\n      lastCh: null,\n      index: curCh,\n      symb: symb,\n      reverseSymb: (forward ? {\n        ')': '(',\n        '}': '{'\n      } : {\n        '(': ')',\n        '{': '}'\n      })[symb],\n      forward: forward,\n      depth: 0,\n      curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode) return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) {\n      init(state);\n    }\n    while (line !== endLine && repeat) {\n      state.index += increment;\n      state.nextCh = state.lineText.charAt(state.index);\n      if (!state.nextCh) {\n        line += increment;\n        state.lineText = cm.getLine(line) || '';\n        if (increment > 0) {\n          state.index = 0;\n        } else {\n          var lineLen = state.lineText.length;\n          state.index = lineLen > 0 ? lineLen - 1 : 0;\n        }\n        state.nextCh = state.lineText.charAt(state.index);\n      }\n      if (isComplete(state)) {\n        cur.line = line;\n        cur.ch = state.index;\n        repeat--;\n      }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n      return Pos(line, state.index);\n    }\n    return cur;\n  }\n\n  /*\n   * Returns the boundaries of the next word. If the cursor in the middle of\n   * the word, then returns the boundaries of the current word, starting at\n   * the cursor. If the cursor is at the start/end of a word, and we are going\n   * forward/backward, respectively, find the boundaries of the next word.\n   *\n   * @param {CodeMirror} cm CodeMirror object.\n   * @param {Cursor} cur The cursor position.\n   * @param {boolean} forward True to search forward. False to search\n   *     backward.\n   * @param {boolean} bigWord True if punctuation count as part of the word.\n   *     False if only [a-zA-Z0-9] characters count as part of the word.\n   * @param {boolean} emptyLineIsWord True if empty lines should be treated\n   *     as words.\n   * @return {Object{from:number, to:number, line: number}} The boundaries of\n   *     the word, or null if there are no more words.\n   */\n  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n    if (emptyLineIsWord && line == '') {\n      lineNum += dir;\n      line = cm.getLine(lineNum);\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      pos = forward ? 0 : line.length;\n    }\n    while (true) {\n      if (emptyLineIsWord && line == '') {\n        return {\n          from: 0,\n          to: 0,\n          line: lineNum\n        };\n      }\n      var stop = dir > 0 ? line.length : -1;\n      var wordStart = stop,\n        wordEnd = stop;\n      // Find bounds of next word.\n      while (pos != stop) {\n        var foundWord = false;\n        for (var i = 0; i < charTests.length && !foundWord; ++i) {\n          if (charTests[i](line.charAt(pos))) {\n            wordStart = pos;\n            // Advance to end of word.\n            while (pos != stop && charTests[i](line.charAt(pos))) {\n              pos += dir;\n            }\n            wordEnd = pos;\n            foundWord = wordStart != wordEnd;\n            if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n              // We started at the end of a word. Find the next one.\n              continue;\n            } else {\n              return {\n                from: Math.min(wordStart, wordEnd + 1),\n                to: Math.max(wordStart, wordEnd),\n                line: lineNum\n              };\n            }\n          }\n        }\n        if (!foundWord) {\n          pos += dir;\n        }\n      }\n      // Advance to next/prev line.\n      lineNum += dir;\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      line = cm.getLine(lineNum);\n      pos = dir > 0 ? 0 : line.length;\n    }\n  }\n\n  /**\n   * @param {CodeMirror} cm CodeMirror object.\n   * @param {Pos} cur The position to start from.\n   * @param {int} repeat Number of words to move past.\n   * @param {boolean} forward True to search forward. False to search\n   *     backward.\n   * @param {boolean} wordEnd True to move to end of word. False to move to\n   *     beginning of word.\n   * @param {boolean} bigWord True if punctuation count as part of the word.\n   *     False if only alphabet characters count as part of the word.\n   * @return {Cursor} The position the cursor should move to.\n   */\n  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if (forward && !wordEnd || !forward && wordEnd) {\n      repeat++;\n    }\n    // For 'e', empty lines are not considered words, go figure.\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n      if (!word) {\n        var eodCh = lineLength(cm, cm.lastLine());\n        words.push(forward ? {\n          line: cm.lastLine(),\n          from: eodCh,\n          to: eodCh\n        } : {\n          line: 0,\n          from: 0,\n          to: 0\n        });\n        break;\n      }\n      words.push(word);\n      cur = Pos(word.line, forward ? word.to - 1 : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n      // w\n      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n        // We did not start in the middle of a word. Discard the extra word at the end.\n        lastWord = words.pop();\n      }\n      return Pos(lastWord.line, lastWord.from);\n    } else if (forward && wordEnd) {\n      return Pos(lastWord.line, lastWord.to - 1);\n    } else if (!forward && wordEnd) {\n      // ge\n      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n        // We did not start in the middle of a word. Discard the extra word at the end.\n        lastWord = words.pop();\n      }\n      return Pos(lastWord.line, lastWord.to);\n    } else {\n      // b\n      return Pos(lastWord.line, lastWord.from);\n    }\n  }\n  function _moveToCharacter(cm, repeat, forward, character) {\n    var cur = cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i++) {\n      var line = cm.getLine(cur.line);\n      idx = charIdxInLine(start, line, character, forward, true);\n      if (idx == -1) {\n        return null;\n      }\n      start = idx;\n    }\n    return Pos(cm.getCursor().line, idx);\n  }\n  function _moveToColumn(cm, repeat) {\n    // repeat is always >= 1, so repeat - 1 always corresponds\n    // to the column we want to go to.\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, Pos(line, repeat - 1));\n  }\n  function updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks)) {\n      return;\n    }\n    if (vim.marks[markName]) {\n      vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n  }\n  function charIdxInLine(start, line, character, forward, includeChar) {\n    // Search for char in line.\n    // motion_options: {forward, includeChar}\n    // If includeChar = true, include it too.\n    // If forward = true, search forward, else search backwards.\n    // If char is not found on this line, do nothing\n    var idx;\n    if (forward) {\n      idx = line.indexOf(character, start + 1);\n      if (idx != -1 && !includeChar) {\n        idx -= 1;\n      }\n    } else {\n      idx = line.lastIndexOf(character, start - 1);\n      if (idx != -1 && !includeChar) {\n        idx += 1;\n      }\n    }\n    return idx;\n  }\n  function findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start,\n      end,\n      i = line;\n    function isEmpty(i) {\n      return !cm.getLine(i);\n    }\n    function isBoundary(i, dir, any) {\n      if (any) {\n        return isEmpty(i) != isEmpty(i + dir);\n      }\n      return !isEmpty(i) && isEmpty(i + dir);\n    }\n    if (dir) {\n      while (min <= i && i <= max && repeat > 0) {\n        if (isBoundary(i, dir)) {\n          repeat--;\n        }\n        i += dir;\n      }\n      return new Pos(i, 0);\n    }\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n      var anchor = vim.sel.anchor;\n      if (isBoundary(anchor.line, -1, true)) {\n        if (!inclusive || anchor.line != line) {\n          line += 1;\n        }\n      }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n      if (isBoundary(i, 1, true)) {\n        if (!inclusive || isEmpty(i) != startState) {\n          repeat--;\n        }\n      }\n    }\n    end = new Pos(i, 0);\n    // select boundary before paragraph for the last one\n    if (i > max && !startState) {\n      startState = true;\n    } else {\n      inclusive = false;\n    }\n    for (i = line; i > min; i--) {\n      if (!inclusive || isEmpty(i) == startState || i == line) {\n        if (isBoundary(i, -1, true)) {\n          break;\n        }\n      }\n    }\n    start = new Pos(i, 0);\n    return {\n      start: start,\n      end: end\n    };\n  }\n  function findSentence(cm, cur, repeat, dir) {\n    /*\n      Takes an index object\n      {\n        line: the line string,\n        ln: line number,\n        pos: index in line,\n        dir: direction of traversal (-1 or 1)\n      }\n      and modifies the line, ln, and pos members to represent the\n      next valid position or sets them to null if there are\n      no more valid positions.\n     */\n    function nextChar(cm, idx) {\n      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n        idx.ln += idx.dir;\n        if (!isLine(cm, idx.ln)) {\n          idx.line = null;\n          idx.ln = null;\n          idx.pos = null;\n          return;\n        }\n        idx.line = cm.getLine(idx.ln);\n        idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n      } else {\n        idx.pos += idx.dir;\n      }\n    }\n\n    /*\n      Performs one iteration of traversal in forward direction\n      Returns an index object of the new location\n     */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var stop = line === \"\";\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: curr.pos\n      };\n      var skip_empty_lines = curr.line === \"\";\n\n      // Move one step to skip character we start on\n      nextChar(cm, curr);\n      while (curr.line !== null) {\n        last_valid.ln = curr.ln;\n        last_valid.pos = curr.pos;\n        if (curr.line === \"\" && !skip_empty_lines) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n          stop = true;\n        }\n        nextChar(cm, curr);\n      }\n\n      /*\n        Set the position to the last non whitespace character on the last\n        valid line in the case that we reach the end of the document.\n      */\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = line.length - 1; i >= 0; --i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n\n    /*\n      Performs one iteration of traversal in reverse direction\n      Returns an index object of the new location\n     */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: null\n      };\n      var skip_empty_lines = curr.line === \"\";\n\n      // Move one step to skip character we start on\n      nextChar(cm, curr);\n      while (curr.line !== null) {\n        if (curr.line === \"\" && !skip_empty_lines) {\n          if (last_valid.pos !== null) {\n            return last_valid;\n          } else {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n          return last_valid;\n        } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          skip_empty_lines = false;\n          last_valid = {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        }\n        nextChar(cm, curr);\n      }\n\n      /*\n        Set the position to the first non whitespace character on the last\n        valid line in the case that we reach the beginning of the document.\n      */\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = 0; i < line.length; ++i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n    return Pos(curr_index.ln, curr_index.pos);\n  }\n\n  // TODO: perhaps this finagling of start and end positions belonds\n  // in codemirror/replaceRange?\n  function selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head,\n      start,\n      end;\n    var bracketRegexp = {\n      '(': /[()]/,\n      ')': /[()]/,\n      '[': /[[\\]]/,\n      ']': /[[\\]]/,\n      '{': /[{}]/,\n      '}': /[{}]/\n    }[symb];\n    var openSym = {\n      '(': '(',\n      ')': '(',\n      '[': '[',\n      ']': '[',\n      '{': '{',\n      '}': '{'\n    }[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    // Due to the behavior of scanForBracket, we need to add an offset if the\n    // cursor is on a matching open bracket.\n    var offset = curChar === openSym ? 1 : 0;\n    start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    start = start.pos;\n    end = end.pos;\n    if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n    if (inclusive) {\n      end.ch += 1;\n    } else {\n      start.ch += 1;\n    }\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  // Takes in a symbol and a cursor and tries to simulate text objects that\n  // have identical opening and closing symbols\n  // TODO support across multiple lines\n  function findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n\n    // the decision tree is to always look backwards for the beginning first,\n    // but if the cursor is in front of the first instance of the symb,\n    // then move the cursor forward\n    if (cur.ch < firstIndex) {\n      cur.ch = firstIndex;\n      // Why is this line even here???\n      // cm.setCursor(cur.line, firstIndex+1);\n    }\n    // otherwise if the cursor is currently on the closing symbol\n    else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n      end = cur.ch; // assign end to the current cursor\n      --cur.ch; // make sure to look backwards\n    }\n\n    // if we're currently on the symbol, we've got a start\n    if (chars[cur.ch] == symb && !end) {\n      start = cur.ch + 1; // assign start to ahead of the cursor\n    } else {\n      // go backwards to find the start\n      for (i = cur.ch; i > -1 && !start; i--) {\n        if (chars[i] == symb) {\n          start = i + 1;\n        }\n      }\n    }\n\n    // look forwards for the end symbol\n    if (start && !end) {\n      for (i = start, len = chars.length; i < len && !end; i++) {\n        if (chars[i] == symb) {\n          end = i;\n        }\n      }\n    }\n\n    // nothing found\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n\n    // include the symbols\n    if (inclusive) {\n      --start;\n      ++end;\n    }\n    return {\n      start: Pos(cur.line, start),\n      end: Pos(cur.line, end)\n    };\n  }\n\n  // Search functions\n  defineOption('pcre', true, 'boolean');\n  function SearchState() {}\n  SearchState.prototype = {\n    getQuery: function getQuery() {\n      return vimGlobalState.query;\n    },\n    setQuery: function setQuery(query) {\n      vimGlobalState.query = query;\n    },\n    getOverlay: function getOverlay() {\n      return this.searchOverlay;\n    },\n    setOverlay: function setOverlay(overlay) {\n      this.searchOverlay = overlay;\n    },\n    isReversed: function isReversed() {\n      return vimGlobalState.isReversed;\n    },\n    setReversed: function setReversed(reversed) {\n      vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function getScrollbarAnnotate() {\n      return this.annotate;\n    },\n    setScrollbarAnnotate: function setScrollbarAnnotate(annotate) {\n      this.annotate = annotate;\n    }\n  };\n  function getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n  }\n  function dialog(cm, template, shortText, onClose, options) {\n    if (cm.openDialog) {\n      cm.openDialog(template, onClose, {\n        bottom: true,\n        value: options.value,\n        onKeyDown: options.onKeyDown,\n        onKeyUp: options.onKeyUp,\n        selectValueOnOpen: false\n      });\n    } else {\n      onClose(prompt(shortText, ''));\n    }\n  }\n  function splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n  }\n  function findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n  }\n  function splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length) return [];\n    var tokens = [];\n    // in case of strings like foo/bar\n    if (slashes[0] !== 0) return;\n    for (var i = 0; i < slashes.length; i++) {\n      if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n    return tokens;\n  }\n  function findUnescapedSeparators(str, separator) {\n    if (!separator) separator = '/';\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n      if (!escapeNextChar && c == separator) {\n        slashes.push(i);\n      }\n      escapeNextChar = !escapeNextChar && c == '\\\\';\n    }\n    return slashes;\n  }\n\n  // Translates a search string from ex (vim) syntax into javascript form.\n  function translateRegex(str) {\n    // When these match, add a '\\' if unescaped or remove one if escaped.\n    var specials = '|(){';\n    // Remove, but never add, a '\\' for these.\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      var specialComesNext = n && specials.indexOf(n) != -1;\n      if (escapeNextChar) {\n        if (c !== '\\\\' || !specialComesNext) {\n          out.push(c);\n        }\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          // Treat the unescape list as special for removing, but not adding '\\'.\n          if (n && unescape.indexOf(n) != -1) {\n            specialComesNext = true;\n          }\n          // Not passing this test means removing a '\\'.\n          if (!specialComesNext || n === '\\\\') {\n            out.push(c);\n          }\n        } else {\n          out.push(c);\n          if (specialComesNext && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n\n  // Translates the replace part of a search and replace from ex (vim) syntax into\n  // javascript form.  Similar to translateRegex, but additionally fixes back references\n  // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n  var charUnescapes = {\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t'\n  };\n  function translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      if (charUnescapes[c + n]) {\n        out.push(charUnescapes[c + n]);\n        i++;\n      } else if (escapeNextChar) {\n        // At any point in the loop, escapeNextChar is true if the previous\n        // character was a '\\' and was not escaped.\n        out.push(c);\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          if (isNumber(n) || n === '$') {\n            out.push('$');\n          } else if (n !== '/' && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        } else {\n          if (c === '$') {\n            out.push('$');\n          }\n          out.push(c);\n          if (n === '/') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n\n  // Unescape \\ and / in the replace part, for PCRE mode.\n  var unescapes = {\n    '\\\\/': '/',\n    '\\\\\\\\': '\\\\',\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t'\n  };\n  function unescapeRegexReplace(str) {\n    var stream = new _cm_adapter2.default.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n      // Search for \\.\n      while (stream.peek() && stream.peek() != '\\\\') {\n        output.push(stream.next());\n      }\n      var matched = false;\n      for (var matcher in unescapes) {\n        if (stream.match(matcher, true)) {\n          matched = true;\n          output.push(unescapes[matcher]);\n          break;\n        }\n      }\n      if (!matched) {\n        // Don't change anything\n        output.push(stream.next());\n      }\n    }\n    return output.join('');\n  }\n\n  /**\n   * Extract the regular expression from the query and return a Regexp object.\n   * Returns null if the query is blank.\n   * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n   * If smartCase is passed in, and the query contains upper case letters,\n   *   then ignoreCase is overridden, and the 'i' flag will not be set.\n   * If the query contains the /i in the flag part of the regular expression,\n   *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n   *   through to the Regex object.\n   */\n  function parseQuery(query, ignoreCase, smartCase) {\n    // First update the last search register\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n    // Check if the query is already a regex.\n    if (query instanceof RegExp) {\n      return query;\n    }\n    // First try to extract regex + flags from the input. If no flags found,\n    // extract just the regex. IE does not accept flags directly defined in\n    // the regex string in the form /regex/flags\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n      // Query looks like 'regexp'\n      regexPart = query;\n    } else {\n      // Query looks like 'regexp/...'\n      regexPart = query.substring(0, slashes[0]);\n      var flagsPart = query.substring(slashes[0]);\n      forceIgnoreCase = flagsPart.indexOf('i') != -1;\n    }\n    if (!regexPart) {\n      return null;\n    }\n    if (!getOption('pcre')) {\n      regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n      ignoreCase = /^[^A-Z]*$/.test(regexPart);\n    }\n    var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'i' : undefined);\n    return regexp;\n  }\n  function showConfirm(cm, text) {\n    if (cm.openNotification) {\n      cm.openNotification('<span style=\"color: red\">' + text + '</span>', {\n        bottom: true,\n        duration: 5000\n      });\n    } else {\n      alert(text);\n    }\n  }\n  function makePrompt(prefix, desc) {\n    var raw = '<span style=\"font-family: monospace; white-space: pre\">' + (prefix || \"\") + '<input type=\"text\"></span>';\n    if (desc) raw += ' <span style=\"color: #888\">' + desc + '</span>';\n    return raw;\n  }\n  var searchPromptDesc = '(Javascript regexp)';\n  function showPrompt(cm, options) {\n    var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n    var prompt = makePrompt(options.prefix, options.desc);\n    dialog(cm, prompt, shortText, options.onClose, options);\n  }\n  function regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n      var props = ['global', 'multiline', 'ignoreCase', 'source'];\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        if (r1[prop] !== r2[prop]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  // Returns true if the query is valid.\n  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n      return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n      return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n      return query;\n    }\n    state.setQuery(query);\n    return query;\n  }\n  function searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n      var matchSol = true;\n    }\n    return {\n      token: function token(stream) {\n        if (matchSol && !stream.sol()) {\n          stream.skipToEnd();\n          return;\n        }\n        var match = stream.match(query, false);\n        if (match) {\n          if (match[0].length == 0) {\n            // Matched empty string, skip to next.\n            stream.next();\n            return 'searching';\n          }\n          if (!stream.sol()) {\n            // Backtrack 1 to match \\b\n            stream.backUp(1);\n            if (!query.exec(stream.next() + match[0])) {\n              stream.next();\n              return null;\n            }\n          }\n          stream.match(query);\n          return 'searching';\n        }\n        while (!stream.eol()) {\n          stream.next();\n          if (stream.match(query, false)) break;\n        }\n      },\n      query: query\n    };\n  }\n  function highlightSearchMatches(cm, query) {\n    var searchState = getSearchState(cm);\n    var overlay = searchState.getOverlay();\n    if (!overlay || query != overlay.query) {\n      if (overlay) {\n        cm.removeOverlay(overlay);\n      }\n      overlay = searchOverlay(query);\n      cm.addOverlay(overlay);\n      if (cm.showMatchesOnScrollbar) {\n        if (searchState.getScrollbarAnnotate()) {\n          searchState.getScrollbarAnnotate().clear();\n        }\n        searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n      }\n      searchState.setOverlay(overlay);\n    }\n  }\n  function _findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      for (var i = 0; i < repeat; i++) {\n        var found = cursor.find(prev);\n        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n          found = cursor.find(prev);\n        }\n        if (!found) {\n          // SearchCursor may have returned null because it hit EOF, wrap\n          // around and try again.\n          cursor = cm.getSearchCursor(query, prev ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0));\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return cursor.from();\n    });\n  }\n  function clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n      state.getScrollbarAnnotate().clear();\n      state.setScrollbarAnnotate(null);\n    }\n  }\n  /**\n   * Check if pos is in the specified range, INCLUSIVE.\n   * Range can be specified with 1 or 2 arguments.\n   * If the first range argument is an array, treat it as an array of line\n   * numbers. Match pos against any of the lines.\n   * If the first range argument is a number,\n   *   if there is only 1 range argument, check if pos has the same line\n   *       number\n   *   if there are 2 range arguments, then check if pos is in between the two\n   *       range arguments.\n   */\n  function isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n      // Assume it is a cursor position. Get the line number.\n      pos = pos.line;\n    }\n    if (start instanceof Array) {\n      return inArray(pos, start);\n    } else {\n      if (end) {\n        return pos >= start && pos <= end;\n      } else {\n        return pos == start;\n      }\n    }\n  }\n  function getUserVisibleLines(cm) {\n    // var scrollInfo = cm.getScrollInfo();\n    // var occludeToleranceTop = 6;\n    // var occludeToleranceBottom = 10;\n    // var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n    // var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n    // var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n    // return {top: from.line, bottom: to.line};\n    return cm.getUserVisibleLines();\n  }\n  function getMarkPos(cm, vim, markName) {\n    if (markName == '\\'') {\n      var history = cm.doc.history.done;\n      var event = history[history.length - 2];\n      return event && event.ranges && event.ranges[0].head;\n    } else if (markName == '.') {\n      if (cm.doc.history.lastModTime == 0) {\n        return; // If no changes, bail out; don't bother to copy or reverse history array.\n      } else {\n        var changeHistory = cm.doc.history.done.filter(function (el) {\n          if (el.changes !== undefined) {\n            return el;\n          }\n        });\n        changeHistory.reverse();\n        var lastEditPos = changeHistory[0].changes[0].to;\n      }\n      return lastEditPos;\n    }\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n  }\n  var ExCommandDispatcher = function ExCommandDispatcher() {\n    this.buildCommandMap_();\n  };\n  ExCommandDispatcher.prototype = {\n    processCommand: function processCommand(cm, input, opt_params) {\n      var that = this;\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n        that._processCommand(cm, input, opt_params);\n      });\n    },\n    _processCommand: function _processCommand(cm, input, opt_params) {\n      var vim = cm.state.vim;\n      var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n      var previousCommand = commandHistoryRegister.toString();\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      var inputStream = new _cm_adapter2.default.StringStream(input);\n      // update \": with the latest command whether valid or invalid\n      commandHistoryRegister.setText(input);\n      var params = opt_params || {};\n      params.input = input;\n      try {\n        this.parseInput_(cm, inputStream, params);\n      } catch (e) {\n        showConfirm(cm, e);\n        throw e;\n      }\n      var command;\n      var commandName;\n      if (!params.commandName) {\n        // If only a line range is defined, move to the line.\n        if (params.line !== undefined) {\n          commandName = 'move';\n        }\n      } else {\n        command = this.matchCommand_(params.commandName);\n        if (command) {\n          commandName = command.name;\n          if (command.excludeFromCommandHistory) {\n            commandHistoryRegister.setText(previousCommand);\n          }\n          this.parseCommandArgs_(inputStream, params, command);\n          if (command.type == 'exToKey') {\n            // Handle Ex to Key mapping.\n            for (var i = 0; i < command.toKeys.length; i++) {\n              _cm_adapter2.default.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n            }\n            return;\n          } else if (command.type == 'exToEx') {\n            // Handle Ex to Ex mapping.\n            this.processCommand(cm, command.toInput);\n            return;\n          }\n        }\n      }\n      if (!commandName) {\n        showConfirm(cm, 'Not an editor command \":' + input + '\"');\n        return;\n      }\n      try {\n        exCommands[commandName](cm, params);\n        // Possibly asynchronous commands (e.g. substitute, which might have a\n        // user confirmation), are responsible for calling the callback when\n        // done. All others have it taken care of for them here.\n        if ((!command || !command.possiblyAsync) && params.callback) {\n          params.callback();\n        }\n      } catch (e) {\n        showConfirm(cm, e);\n        throw e;\n      }\n    },\n    parseInput_: function parseInput_(cm, inputStream, result) {\n      inputStream.eatWhile(':');\n      // Parse range.\n      if (inputStream.eat('%')) {\n        result.line = cm.firstLine();\n        result.lineEnd = cm.lastLine();\n      } else {\n        result.line = this.parseLineSpec_(cm, inputStream);\n        if (result.line !== undefined && inputStream.eat(',')) {\n          result.lineEnd = this.parseLineSpec_(cm, inputStream);\n        }\n      }\n\n      // Parse command name.\n      var commandMatch = inputStream.match(/^(\\w+)/);\n      if (commandMatch) {\n        result.commandName = commandMatch[1];\n      } else {\n        result.commandName = inputStream.match(/.*/)[0];\n      }\n      return result;\n    },\n    parseLineSpec_: function parseLineSpec_(cm, inputStream) {\n      var numberMatch = inputStream.match(/^(\\d+)/);\n      if (numberMatch) {\n        // Absolute line number plus offset (N+M or N-M) is probably a typo,\n        // not something the user actually wanted. (NB: vim does allow this.)\n        return parseInt(numberMatch[1], 10) - 1;\n      }\n      switch (inputStream.next()) {\n        case '.':\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        case '$':\n          return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n        case '\\'':\n          var markName = inputStream.next();\n          var markPos = getMarkPos(cm, cm.state.vim, markName);\n          if (!markPos) throw new Error('Mark not set');\n          return this.parseLineSpecOffset_(inputStream, markPos.line);\n        case '-':\n        case '+':\n          inputStream.backUp(1);\n          // Offset is relative to current line if not otherwise specified.\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        default:\n          inputStream.backUp(1);\n          return undefined;\n      }\n    },\n    parseLineSpecOffset_: function parseLineSpecOffset_(inputStream, line) {\n      var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n      if (offsetMatch) {\n        var offset = parseInt(offsetMatch[2], 10);\n        if (offsetMatch[1] == \"-\") {\n          line -= offset;\n        } else {\n          line += offset;\n        }\n      }\n      return line;\n    },\n    parseCommandArgs_: function parseCommandArgs_(inputStream, params, command) {\n      if (inputStream.eol()) {\n        return;\n      }\n      params.argString = inputStream.match(/.*/)[0];\n      // Parse command-line arguments\n      var delim = command.argDelimiter || /\\s+/;\n      var args = trim(params.argString).split(delim);\n      if (args.length && args[0]) {\n        params.args = args;\n      }\n    },\n    matchCommand_: function matchCommand_(commandName) {\n      // Return the command in the command map that matches the shortest\n      // prefix of the passed in command name. The match is guaranteed to be\n      // unambiguous if the defaultExCommandMap's shortNames are set up\n      // correctly. (see @code{defaultExCommandMap}).\n      for (var i = commandName.length; i > 0; i--) {\n        var prefix = commandName.substring(0, i);\n        if (this.commandMap_[prefix]) {\n          var command = this.commandMap_[prefix];\n          if (command.name.indexOf(commandName) === 0) {\n            return command;\n          }\n        }\n      }\n      return null;\n    },\n    buildCommandMap_: function buildCommandMap_() {\n      this.commandMap_ = {};\n      for (var i = 0; i < defaultExCommandMap.length; i++) {\n        var command = defaultExCommandMap[i];\n        var key = command.shortName || command.name;\n        this.commandMap_[key] = command;\n      }\n    },\n    map: function map(lhs, rhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n        var commandName = lhs.substring(1);\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          // Ex to Ex mapping\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToEx',\n            toInput: rhs.substring(1),\n            user: true\n          };\n        } else {\n          // Ex to key mapping\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToKey',\n            toKeys: rhs,\n            user: true\n          };\n        }\n      } else {\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          // Key to Ex mapping.\n          var mapping = {\n            keys: lhs,\n            type: 'keyToEx',\n            exArgs: {\n              input: rhs.substring(1)\n            }\n          };\n          if (ctx) {\n            mapping.context = ctx;\n          }\n          defaultKeymap.unshift(mapping);\n        } else {\n          // Key to key mapping\n          var mapping = {\n            keys: lhs,\n            type: 'keyToKey',\n            toKeys: rhs\n          };\n          if (ctx) {\n            mapping.context = ctx;\n          }\n          defaultKeymap.unshift(mapping);\n        }\n      }\n    },\n    unmap: function unmap(lhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        // Ex to Ex or Ex to key mapping\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n        var commandName = lhs.substring(1);\n        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n          delete this.commandMap_[commandName];\n          return;\n        }\n      } else {\n        // Key to Ex or key to key mapping\n        var keys = lhs;\n        for (var i = 0; i < defaultKeymap.length; i++) {\n          if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n            defaultKeymap.splice(i, 1);\n            return;\n          }\n        }\n      }\n      throw Error('No such mapping.');\n    }\n  };\n  var exCommands = {\n    colorscheme: function colorscheme(cm, params) {\n      if (!params.args || params.args.length < 1) {\n        showConfirm(cm, cm.getOption('theme'));\n        return;\n      }\n      cm.setOption('theme', params.args[0]);\n    },\n    map: function map(cm, params, ctx) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 2) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n    },\n    imap: function imap(cm, params) {\n      this.map(cm, params, 'insert');\n    },\n    nmap: function nmap(cm, params) {\n      this.map(cm, params, 'normal');\n    },\n    vmap: function vmap(cm, params) {\n      this.map(cm, params, 'visual');\n    },\n    unmap: function unmap(cm, params, ctx) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, 'No such mapping: ' + params.input);\n        }\n        return;\n      }\n      exCommandDispatcher.unmap(mapArgs[0], ctx);\n    },\n    move: function move(cm, params) {\n      commandDispatcher.processCommand(cm, cm.state.vim, {\n        type: 'motion',\n        motion: 'moveToLineOrEdgeOfDocument',\n        motionArgs: {\n          forward: false,\n          explicitRepeat: true,\n          linewise: true\n        },\n        repeatOverride: params.line + 1\n      });\n    },\n    set: function set(cm, params) {\n      var setArgs = params.args;\n      // Options passed through to the setOption/getOption calls. May be passed in by the\n      // local/global versions of the set command\n      var setCfg = params.setCfg || {};\n      if (!setArgs || setArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      var expr = setArgs[0].split('=');\n      var optionName = expr[0];\n      var value = expr[1];\n      var forceGet = false;\n      if (optionName.charAt(optionName.length - 1) == '?') {\n        // If post-fixed with ?, then the set is actually a get.\n        if (value) {\n          throw Error('Trailing characters: ' + params.argString);\n        }\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceGet = true;\n      }\n      if (value === undefined && optionName.substring(0, 2) == 'no') {\n        // To set boolean options to false, the option name is prefixed with\n        // 'no'.\n        optionName = optionName.substring(2);\n        value = false;\n      }\n      var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n      if (optionIsBoolean && value == undefined) {\n        // Calling set with a boolean option sets it to true.\n        value = true;\n      }\n      // If no value is provided, then we assume this is a get.\n      if (!optionIsBoolean && value === undefined || forceGet) {\n        var oldValue = getOption(optionName, cm, setCfg);\n        if (oldValue instanceof Error) {\n          showConfirm(cm, oldValue.message);\n        } else if (oldValue === true || oldValue === false) {\n          showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n        } else {\n          showConfirm(cm, '  ' + optionName + '=' + oldValue);\n        }\n      } else {\n        var setOptionReturn = setOption(optionName, value, cm, setCfg);\n        if (setOptionReturn instanceof Error) {\n          showConfirm(cm, setOptionReturn.message);\n        }\n      }\n    },\n    setlocal: function setlocal(cm, params) {\n      // setCfg is passed through to setOption\n      params.setCfg = {\n        scope: 'local'\n      };\n      this.set(cm, params);\n    },\n    setglobal: function setglobal(cm, params) {\n      // setCfg is passed through to setOption\n      params.setCfg = {\n        scope: 'global'\n      };\n      this.set(cm, params);\n    },\n    registers: function registers(cm, params) {\n      var regArgs = params.args;\n      var registers = vimGlobalState.registerController.registers;\n      var regInfo = '----------Registers----------<br><br>';\n      if (!regArgs) {\n        for (var registerName in registers) {\n          var text = registers[registerName].toString();\n          if (text.length) {\n            regInfo += '\"' + registerName + '    ' + text + '<br>';\n          }\n        }\n      } else {\n        var registerName;\n        regArgs = regArgs.join('');\n        for (var i = 0; i < regArgs.length; i++) {\n          registerName = regArgs.charAt(i);\n          if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n            continue;\n          }\n          var register = registers[registerName] || new Register();\n          regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n        }\n      }\n      showConfirm(cm, regInfo);\n    },\n    sort: function sort(cm, params) {\n      var reverse, ignoreCase, unique, number, pattern;\n      function parseArgs() {\n        if (params.argString) {\n          var args = new _cm_adapter2.default.StringStream(params.argString);\n          if (args.eat('!')) {\n            reverse = true;\n          }\n          if (args.eol()) {\n            return;\n          }\n          if (!args.eatSpace()) {\n            return 'Invalid arguments';\n          }\n          var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n          if (!opts && !args.eol()) {\n            return 'Invalid arguments';\n          }\n          if (opts[1]) {\n            ignoreCase = opts[1].indexOf('i') != -1;\n            unique = opts[1].indexOf('u') != -1;\n            var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n            var hex = opts[1].indexOf('x') != -1 && 1;\n            var octal = opts[1].indexOf('o') != -1 && 1;\n            if (decimal + hex + octal > 1) {\n              return 'Invalid arguments';\n            }\n            number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n          }\n          if (opts[2]) {\n            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n          }\n        }\n      }\n      var err = parseArgs();\n      if (err) {\n        showConfirm(cm, err + ': ' + params.argString);\n        return;\n      }\n      var lineStart = params.line || cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      if (lineStart == lineEnd) {\n        return;\n      }\n      var curStart = Pos(lineStart, 0);\n      var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n      var text = cm.getRange(curStart, curEnd).split('\\n');\n      var numberRegex = pattern ? pattern : number == 'decimal' ? /(-?)([\\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;\n      var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : null;\n      var numPart = [],\n        textPart = [];\n      if (number || pattern) {\n        for (var i = 0; i < text.length; i++) {\n          var matchPart = pattern ? text[i].match(pattern) : null;\n          if (matchPart && matchPart[0] != '') {\n            numPart.push(matchPart);\n          } else if (!pattern && numberRegex.exec(text[i])) {\n            numPart.push(text[i]);\n          } else {\n            textPart.push(text[i]);\n          }\n        }\n      } else {\n        textPart = text;\n      }\n      function compareFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a = a.toLowerCase();\n          b = b.toLowerCase();\n        }\n        var anum = number && numberRegex.exec(a);\n        var bnum = number && numberRegex.exec(b);\n        if (!anum) {\n          return a < b ? -1 : 1;\n        }\n        anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n        bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n        return anum - bnum;\n      }\n      function comparePatternFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a[0] = a[0].toLowerCase();\n          b[0] = b[0].toLowerCase();\n        }\n        return a[0] < b[0] ? -1 : 1;\n      }\n      numPart.sort(pattern ? comparePatternFn : compareFn);\n      if (pattern) {\n        for (var i = 0; i < numPart.length; i++) {\n          numPart[i] = numPart[i].input;\n        }\n      } else if (!number) {\n        textPart.sort(compareFn);\n      }\n      text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n      if (unique) {\n        // Remove duplicate lines\n        var textOld = text;\n        var lastLine;\n        text = [];\n        for (var i = 0; i < textOld.length; i++) {\n          if (textOld[i] != lastLine) {\n            text.push(textOld[i]);\n          }\n          lastLine = textOld[i];\n        }\n      }\n      cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    global: function global(cm, params) {\n      // a global command is of the form\n      // :[range]g/pattern/[cmd]\n      // argString holds the string /pattern/[cmd]\n      var argString = params.argString;\n      if (!argString) {\n        showConfirm(cm, 'Regular Expression missing from global');\n        return;\n      }\n      // range is specified here\n      var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      // get the tokens from argString\n      var tokens = splitBySlash(argString);\n      var regexPart = argString,\n        cmd;\n      if (tokens.length) {\n        regexPart = tokens[0];\n        cmd = tokens.slice(1, tokens.length).join('/');\n      }\n      if (regexPart) {\n        // If regex part is empty, then use the previous query. Otherwise\n        // use the regex part as the new query.\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      // now that we have the regexPart, search for regex matches in the\n      // specified range of lines\n      var query = getSearchState(cm).getQuery();\n      var matchedLines = [],\n        content = '';\n      for (var i = lineStart; i <= lineEnd; i++) {\n        var matched = query.test(cm.getLine(i));\n        if (matched) {\n          matchedLines.push(i + 1);\n          content += cm.getLine(i) + '<br>';\n        }\n      }\n      // if there is no [cmd], just display the list of matched lines\n      if (!cmd) {\n        showConfirm(cm, content);\n        return;\n      }\n      var index = 0;\n      var nextCommand = function nextCommand() {\n        if (index < matchedLines.length) {\n          var command = matchedLines[index] + cmd;\n          exCommandDispatcher.processCommand(cm, command, {\n            callback: nextCommand\n          });\n        }\n        index++;\n      };\n      nextCommand();\n    },\n    substitute: function substitute(cm, params) {\n      if (!cm.getSearchCursor) {\n        throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');\n      }\n      var argString = params.argString;\n      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n      var regexPart,\n        replacePart = '',\n        trailing,\n        flagsPart,\n        count;\n      var confirm = false; // Whether to confirm each replace.\n      var global = false; // True to replace all instances on a line, false to replace only 1.\n      if (tokens.length) {\n        regexPart = tokens[0];\n        replacePart = tokens[1];\n        if (regexPart && regexPart[regexPart.length - 1] === '$') {\n          regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n          replacePart = replacePart ? replacePart + '\\n' : '\\n';\n        }\n        if (replacePart !== undefined) {\n          if (getOption('pcre')) {\n            replacePart = unescapeRegexReplace(replacePart);\n          } else {\n            replacePart = translateRegexReplace(replacePart);\n          }\n          vimGlobalState.lastSubstituteReplacePart = replacePart;\n        }\n        trailing = tokens[2] ? tokens[2].split(' ') : [];\n      } else {\n        // either the argString is empty or its of the form ' hello/world'\n        // actually splitBySlash returns a list of tokens\n        // only if the string starts with a '/'\n        if (argString && argString.length) {\n          showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');\n          return;\n        }\n      }\n      // After the 3rd slash, we can have flags followed by a space followed\n      // by count.\n      if (trailing) {\n        flagsPart = trailing[0];\n        count = parseInt(trailing[1]);\n        if (flagsPart) {\n          if (flagsPart.indexOf('c') != -1) {\n            confirm = true;\n            flagsPart.replace('c', '');\n          }\n          if (flagsPart.indexOf('g') != -1) {\n            global = true;\n            flagsPart.replace('g', '');\n          }\n          regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n        }\n      }\n      if (regexPart) {\n        // If regex part is empty, then use the previous query. Otherwise use\n        // the regex part as the new query.\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n      if (replacePart === undefined) {\n        showConfirm(cm, 'No previous substitute regular expression');\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n      var lineEnd = params.lineEnd || lineStart;\n      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n        lineEnd = Infinity;\n      }\n      if (count) {\n        lineStart = lineEnd;\n        lineEnd = lineStart + count - 1;\n      }\n      var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n      var cursor = cm.getSearchCursor(query, startPos);\n      doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    redo: _cm_adapter2.default.commands.redo,\n    undo: _cm_adapter2.default.commands.undo,\n    write: function write(cm) {\n      if (_cm_adapter2.default.commands.save) {\n        // If a save command is defined, call it.\n        _cm_adapter2.default.commands.save(cm);\n      } else if (cm.save) {\n        // Saves to text area if no save command is defined and cm.save() is available.\n        cm.save();\n      }\n    },\n    nohlsearch: function nohlsearch(cm) {\n      clearSearchHighlight(cm);\n    },\n    yank: function yank(cm) {\n      var cur = copyCursor(cm.getCursor());\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n    },\n    delmarks: function delmarks(cm, params) {\n      if (!params.argString || !trim(params.argString)) {\n        showConfirm(cm, 'Argument required');\n        return;\n      }\n      var state = cm.state.vim;\n      var stream = new _cm_adapter2.default.StringStream(trim(params.argString));\n      while (!stream.eol()) {\n        stream.eatSpace();\n\n        // Record the streams position at the beginning of the loop for use\n        // in error messages.\n        var count = stream.pos;\n        if (!stream.match(/[a-zA-Z]/, false)) {\n          showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n          return;\n        }\n        var sym = stream.next();\n        // Check if this symbol is part of a range\n        if (stream.match('-', true)) {\n          // This symbol is part of a range.\n\n          // The range must terminate at an alphabetic character.\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n          var startMark = sym;\n          var finishMark = stream.next();\n          // The range must terminate at an alphabetic character which\n          // shares the same case as the start of the range.\n          if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {\n            var start = startMark.charCodeAt(0);\n            var finish = finishMark.charCodeAt(0);\n            if (start >= finish) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            // Because marks are always ASCII values, and we have\n            // determined that they are the same case, we can use\n            // their char codes to iterate through the defined range.\n            for (var j = 0; j <= finish - start; j++) {\n              var mark = String.fromCharCode(start + j);\n              delete state.marks[mark];\n            }\n          } else {\n            showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n            return;\n          }\n        } else {\n          // This symbol is a valid mark, and is not part of a range.\n          delete state.marks[sym];\n        }\n      }\n    }\n  };\n  var exCommandDispatcher = new ExCommandDispatcher();\n\n  /**\n  * @param {CodeMirror} cm CodeMirror instance we are in.\n  * @param {boolean} confirm Whether to confirm each replace.\n  * @param {Cursor} lineStart Line to start replacing from.\n  * @param {Cursor} lineEnd Line to stop replacing at.\n  * @param {RegExp} query Query for performing matches with.\n  * @param {string} replaceWith Text to replace matches with. May contain $1,\n  *     $2, etc for replacing captured groups using Javascript replace.\n  * @param {function()} callback A callback for when the replace is done.\n  */\n  function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    // Set up all the functions.\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos = searchCursor.from();\n    function replaceAll() {\n      cm.operation(function () {\n        while (!done) {\n          replace();\n          next();\n        }\n        stop();\n      });\n    }\n    function replace() {\n      var text = cm.getRange(searchCursor.from(), searchCursor.to());\n      var newText = text.replace(query, replaceWith);\n      searchCursor.replace(newText);\n    }\n    function next() {\n      // The below only loops to skip over multiple occurrences on the same\n      // line when 'global' is not true.\n      while (searchCursor.findNext() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n        if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n          continue;\n        }\n        cm.scrollIntoView(searchCursor.from(), 30);\n        cm.setSelection(searchCursor.from(), searchCursor.to());\n        lastPos = searchCursor.from();\n        done = false;\n        return;\n      }\n      done = true;\n    }\n    function stop(close) {\n      if (close) {\n        close();\n      }\n      cm.focus();\n      if (lastPos) {\n        cm.setCursor(lastPos);\n        var vim = cm.state.vim;\n        vim.exMode = false;\n        vim.lastHPos = vim.lastHSPos = lastPos.ch;\n      }\n      if (callback) {\n        callback();\n      }\n    }\n    function onPromptKeyDown(e, _value, close) {\n      // Swallow all keys.\n      _cm_adapter2.default.e_stop(e);\n      var keyName = _cm_adapter2.default.keyName(e);\n      switch (keyName) {\n        case 'y':\n        case 'Y':\n          replace();\n          next();\n          break;\n        case 'n':\n        case 'N':\n          next();\n          break;\n        case 'a':\n        case 'A':\n          // replaceAll contains a call to close of its own. We don't want it\n          // to fire too early or multiple times.\n          var savedCallback = callback;\n          callback = undefined;\n          cm.operation(replaceAll);\n          callback = savedCallback;\n          break;\n        case 'l':\n        case 'L':\n          replace();\n        // fall through and exit.\n        case 'q':\n        case 'Q':\n        case 'Esc':\n        case 'Ctrl-C':\n        case 'Ctrl-[':\n          stop(close);\n          break;\n      }\n      if (done) {\n        stop(close);\n      }\n      return true;\n    }\n\n    // Actually do replace.\n    next();\n    if (done) {\n      showConfirm(cm, 'No matches for ' + query.source);\n      return;\n    }\n    if (!confirm) {\n      replaceAll();\n      if (callback) {\n        callback();\n      }\n      return;\n    }\n    showPrompt(cm, {\n      prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n      onKeyDown: onPromptKeyDown\n    });\n  }\n  _cm_adapter2.default.keyMap.vim = {\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n  function exitInsertMode(cm) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    // In case of visual block, the insertModeChanges are not saved as a\n    // single word, so we convert them to a single word\n    // so as to update the \". register as expected in real vim.\n    var text = [];\n    if (!isPlaying) {\n      var selLength = lastChange.inVisualBlock && vim.lastSelection ? vim.lastSelection.visualBlock.height : 1;\n      var changes = lastChange.changes;\n      var text = [];\n      var i = 0;\n      // In case of multiple selections in blockwise visual,\n      // the inserted text, for example: 'f<Backspace>oo', is stored as\n      // 'f', 'f', InsertModeKey 'o', 'o', 'o', 'o'. (if you have a block with 2 lines).\n      // We push the contents of the changes array as per the following:\n      // 1. In case of InsertModeKey, just increment by 1.\n      // 2. In case of a character, jump by selLength (2 in the example).\n      while (i < changes.length) {\n        // This loop will convert 'ff<bs>oooo' to 'f<bs>oo'.\n        text.push(changes[i]);\n        if (changes[i] instanceof InsertModeKey) {\n          i++;\n        } else {\n          i += selLength;\n        }\n      }\n      lastChange.changes = text;\n      cm.off('change', onChange);\n      _cm_adapter2.default.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n      // Perform insert mode repeat for commands like 3,a and 3,o.\n      _repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);\n      vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    // update the \". register before exiting insert mode\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    _cm_adapter2.default.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    if (macroModeState.isRecording) {\n      logInsertModeChange(macroModeState);\n    }\n    cm.enterVimMode();\n  }\n  function _mapCommand(command) {\n    defaultKeymap.unshift(command);\n  }\n  function mapCommand(keys, type, name, args, extra) {\n    var command = {\n      keys: keys,\n      type: type\n    };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra) {\n      command[key] = extra[key];\n    }\n    _mapCommand(command);\n  }\n\n  // The timeout in milliseconds for the two-character ESC keymap should be\n  // adjusted according to your typing speed to prevent false positives.\n  defineOption('insertModeEscKeysTimeout', 200, 'number');\n  _cm_adapter2.default.keyMap['vim-insert'] = {\n    // TODO: override navigation keys so that Esc will cancel automatic\n    // indentation from o, O, i_<CR>\n    fallthrough: ['default'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n  _cm_adapter2.default.keyMap['vim-replace'] = {\n    'Backspace': 'goCharLeft',\n    fallthrough: ['vim-insert'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n  function executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == ':') {\n      // Read-only register containing last Ex command.\n      if (register.keyBuffer[0]) {\n        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n      }\n      macroModeState.isPlaying = false;\n      return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n      var text = keyBuffer[i];\n      var match, key;\n      while (text) {\n        // Pull off one command key, which is either a single character\n        // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n        match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n        key = match[0];\n        text = text.substring(match.index + key.length);\n        _cm_adapter2.default.Vim.handleKey(cm, key, 'macro');\n        if (vim.insertMode) {\n          var changes = register.insertModeChanges[imc++].changes;\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n          repeatInsertModeChanges(cm, changes, 1);\n          exitInsertMode(cm);\n        }\n      }\n    }\n    macroModeState.isPlaying = false;\n  }\n  function logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n      register.pushText(key);\n    }\n  }\n  function logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n  }\n  function logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n      register.pushSearchQuery(query);\n    }\n  }\n\n  /**\n   * Listens for changes made in insert mode.\n   * Should only be active in insert mode.\n   */\n  function onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n      while (changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n        if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined /* only in testing */) {\n          var text = changeObj.text.join('\\n');\n          if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n          }\n          if (cm.state.overwrite && !/\\n/.test(text)) {\n            lastChange.changes.push([text]);\n          } else {\n            lastChange.changes.push(text);\n          }\n        }\n        // Change objects may be chained with next.\n        changeObj = changeObj.next;\n      }\n    }\n  }\n\n  /**\n  * Listens for any kind of cursor activity on CodeMirror.\n  */\n  function onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n      // Tracking cursor activity in insert mode (for macro support).\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        // Cursor moved outside the context of an edit. Reset the change.\n        lastChange.maybeReset = true;\n      }\n    } else if (!cm.curOp.isVimOp) {\n      handleExternalSelection(cm, vim);\n    }\n    if (vim.visualMode) {\n      updateFakeCursor(cm);\n    }\n  }\n  function updateFakeCursor(cm) {\n    var vim = cm.state.vim;\n    var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n    var to = offsetCursor(from, 0, 1);\n    if (vim.fakeCursor) {\n      vim.fakeCursor.clear();\n    }\n    vim.fakeCursor = cm.markText(from, to, {\n      className: 'cm-animate-fat-cursor'\n    });\n  }\n  function handleExternalSelection(cm, vim) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n    // Enter or exit visual mode to match mouse selection.\n    if (vim.visualMode && !cm.somethingSelected()) {\n      exitVisualMode(cm, false);\n    } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n      vim.visualMode = true;\n      vim.visualLine = false;\n      _cm_adapter2.default.signal(cm, \"vim-mode-change\", {\n        mode: \"visual\"\n      });\n    }\n    if (vim.visualMode) {\n      // Bind CodeMirror selection model to vim selection model.\n      // Mouse selections are considered visual characterwise.\n      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n      head = offsetCursor(head, 0, headOffset);\n      anchor = offsetCursor(anchor, 0, anchorOffset);\n      vim.sel = {\n        anchor: anchor,\n        head: head\n      };\n      updateMark(cm, vim, '<', cursorMin(head, anchor));\n      updateMark(cm, vim, '>', cursorMax(head, anchor));\n    } else if (!vim.insertMode) {\n      // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n      vim.lastHPos = cm.getCursor().ch;\n    }\n  }\n\n  /** Wrapper for special keys pressed in insert mode */\n  function InsertModeKey(keyName) {\n    this.keyName = keyName;\n  }\n\n  /**\n  * Handles raw key down events from the text area.\n  * - Should only be active in insert mode.\n  * - For recording deletes in insert mode.\n  */\n  function onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = _cm_adapter2.default.keyName(e);\n    if (!keyName) {\n      return;\n    }\n    function onKeyFound() {\n      if (lastChange.maybeReset) {\n        lastChange.changes = [];\n        lastChange.maybeReset = false;\n      }\n      lastChange.changes.push(new InsertModeKey(keyName));\n      return true;\n    }\n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n      _cm_adapter2.default.lookupKey(keyName, 'vim-insert', onKeyFound);\n    }\n  }\n\n  /**\n   * Repeats the last edit, which includes exactly 1 command and at most 1\n   * insert. Operator and motion commands are read from lastEditInputState,\n   * while action commands are read from lastEditActionCommand.\n   *\n   * If repeatForInsert is true, then the function was called by\n   * exitInsertMode to repeat the insert mode changes the user just made. The\n   * corresponding enterInsertMode call was made with a count.\n   */\n  function _repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n      if (isAction) {\n        commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n      } else {\n        commandDispatcher.evalInput(cm, vim);\n      }\n    }\n    function repeatInsert(repeat) {\n      if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n        // For some reason, repeat cw in desktop VIM does not repeat\n        // insert mode changes. Will conform to that behavior.\n        repeat = !vim.lastEditActionCommand ? 1 : repeat;\n        var changeObject = macroModeState.lastInsertModeChanges;\n        repeatInsertModeChanges(cm, changeObject.changes, repeat);\n      }\n    }\n    vim.inputState = vim.lastEditInputState;\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n      // o and O repeat have to be interlaced with insert repeats so that the\n      // insertions appear on separate lines instead of the last line.\n      for (var i = 0; i < repeat; i++) {\n        repeatCommand();\n        repeatInsert(1);\n      }\n    } else {\n      if (!repeatForInsert) {\n        // Hack to get the cursor to end up at the right place. If I is\n        // repeated in insert mode repeat, cursor will be 1 insert\n        // change set left of where it should be.\n        repeatCommand();\n      }\n      repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n      // Don't exit insert mode twice. If repeatForInsert is set, then we\n      // were called by an exitInsertMode call lower on the stack.\n      exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n  }\n  function repeatInsertModeChanges(cm, changes, repeat) {\n    function keyHandler(binding) {\n      if (typeof binding == 'string') {\n        _cm_adapter2.default.commands[binding](cm);\n      } else {\n        binding(cm);\n      }\n      return true;\n    }\n    var head = cm.getCursor('head');\n    var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;\n    if (inVisualBlock) {\n      // Set up block selection again for repeating the changes.\n      var vim = cm.state.vim;\n      var lastSel = vim.lastSelection;\n      var offset = getOffset(lastSel.anchor, lastSel.head);\n      selectForInsert(cm, head, offset.line + 1);\n      repeat = cm.listSelections().length;\n      cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n      if (inVisualBlock) {\n        cm.setCursor(offsetCursor(head, i, 0));\n      }\n      for (var j = 0; j < changes.length; j++) {\n        var change = changes[j];\n        if (change instanceof InsertModeKey) {\n          _cm_adapter2.default.lookupKey(change.keyName, 'vim-insert', keyHandler);\n        } else if (typeof change == \"string\") {\n          var cur = cm.getCursor();\n          cm.replaceRange(change, cur, cur);\n        } else {\n          var start = cm.getCursor();\n          var end = offsetCursor(start, 0, change[0].length);\n          cm.replaceRange(change[0], start, end);\n        }\n      }\n    }\n    if (inVisualBlock) {\n      cm.setCursor(offsetCursor(head, 0, 1));\n    }\n  }\n  resetVimGlobalState();\n  return vimApi;\n};\n_cm_adapter2.default.Vim = Vim();\nexports.Vim = Vim;\nexports.default = _cm_adapter2.default;"],"sourceRoot":""}